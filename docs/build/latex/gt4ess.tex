%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{gt4ess Documentation}
\date{Feb 06, 2018}
\release{0.1.0}
\author{Stefano Ubbiali}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{API Documentation}
\label{\detokenize{api:welcome-to-gt4ess-s-documentation}}\label{\detokenize{api:api-documentation}}\label{\detokenize{api::doc}}

\section{Axis}
\label{\detokenize{api:axis}}\index{Axis (class in grids.axis)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.axis.Axis}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.axis.}\sphinxbfcode{Axis}}{\emph{coords}, \emph{dims}, \emph{attrs=None}}{}
Class representing a one-dimensional axis. The class API has been designed to be similar to
that provided by \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}}.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coords} (\sphinxstyleliteralemphasis{list}) \textendash{} One-dimensional \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} storing axis coordinates, wrapped
within a list.

\item {} 
\sphinxstyleliteralstrong{values} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} One-dimensional \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} storing axis coordinates.
This attrribute is semantically identical to \sphinxcode{coords} and it is
introduced just for the sake of compliancy with \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}}’s API.

\item {} 
\sphinxstyleliteralstrong{dims} (\sphinxstyleliteralemphasis{list}) \textendash{} Axis dimension, i.e., label.

\item {} 
\sphinxstyleliteralstrong{attrs} (\sphinxstyleliteralemphasis{dict}) \textendash{} Axis attributes, e.g., the units.

\end{itemize}

\end{description}\end{quote}
\index{\_\_getitem\_\_() (grids.axis.Axis method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.axis.Axis.__getitem__}}\pysiglinewithargsret{\sphinxbfcode{\_\_getitem\_\_}}{\emph{i}}{}
Get directly access to the coordinate vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{i} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} The index, or a sequence of indices.

\item[{Returns}] \leavevmode
The coordinate(s).

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (grids.axis.Axis method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.axis.Axis.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{coords}, \emph{dims}, \emph{attrs=None}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coords} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} Axis coordinates. Must be a one-dimensional \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}}.

\item {} 
\sphinxstyleliteralstrong{dims} (\sphinxstyleliteralemphasis{str}) \textendash{} Axis label.

\item {} 
\sphinxstyleliteralstrong{attrs} (\sphinxtitleref{dict}, optional) \textendash{} 
Axis attributes. This may be used to specify, e.g., the units,
which, following the \sphinxhref{http://cfconventions.org}{CF Conventions}, may be either:
\begin{itemize}
\item {} 
’m’ (meters) or multiples, for height-based coordinates;

\item {} 
’Pa’ (Pascal) or multiples, for pressure-based coordinates;

\item {} 
’K’ (Kelvin), for temperature-based coordinates;

\item {} 
’degrees\_east’, for longitude; or

\item {} 
’degrees\_north’, for latitude.

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Dynamical core}
\label{\detokenize{api:dynamical-core}}

\subsection{Diagnostics}
\label{\detokenize{api:diagnostics}}\index{IsentropicDiagnostic (class in dycore.isentropic\_diagnostic)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_diagnostic.IsentropicDiagnostic}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.isentropic\_diagnostic.}\sphinxbfcode{IsentropicDiagnostic}}{\emph{grid}, \emph{imoist}, \emph{backend}}{}
Class implementing the diagnostic step of the three-dimensional moist isentropic dynamical core.
\index{\_\_init\_\_() (dycore.isentropic\_diagnostic.IsentropicDiagnostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_diagnostic.IsentropicDiagnostic.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{imoist}, \emph{backend}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} or one of its
derived classes.

\item {} 
\sphinxstyleliteralstrong{imoist} (\sphinxstyleliteralemphasis{bool}) \textendash{} \sphinxcode{True} for a moist dynamical core, \sphinxcode{False} otherwise.

\item {} 
\sphinxstyleliteralstrong{backend} (\sphinxtitleref{obj}, optional) \textendash{} \sphinxcode{gridtools.mode} specifying the backend for the GT4Py’s stencil
implementing numerical diffusion.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_conservative\_variables() (dycore.isentropic\_diagnostic.IsentropicDiagnostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_diagnostic.IsentropicDiagnostic.get_conservative_variables}}\pysiglinewithargsret{\sphinxbfcode{get\_conservative\_variables}}{\emph{s}, \emph{u}, \emph{v}, \emph{qv=None}, \emph{qc=None}, \emph{qr=None}}{}
Diagnosis of the conservative model variables, i.e., the momentums \(U\) and \(V\),
and, optionally, \(Q_v\), \(Q_c\) and \(Q_r\).

\end{fulllineitems}

\index{get\_diagnostic\_variables() (dycore.isentropic\_diagnostic.IsentropicDiagnostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_diagnostic.IsentropicDiagnostic.get_diagnostic_variables}}\pysiglinewithargsret{\sphinxbfcode{get\_diagnostic\_variables}}{\emph{s}, \emph{pt}}{}
Diagnostic of the pressure, the Montgomery potential and the geometrical height of the isentropes.

\end{fulllineitems}

\index{get\_nonconservative\_variables() (dycore.isentropic\_diagnostic.IsentropicDiagnostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_diagnostic.IsentropicDiagnostic.get_nonconservative_variables}}\pysiglinewithargsret{\sphinxbfcode{get\_nonconservative\_variables}}{\emph{s}, \emph{U}, \emph{V}, \emph{Qv=None}, \emph{Qc=None}, \emph{Qr=None}}{}
Diagnosis of the non-conservative model variables, i.e., \(u\), \(v\), \(q_v\),
\(q_c\) and \(q_r\).

\end{fulllineitems}


\end{fulllineitems}



\subsection{Lateral boundary conditions}
\label{\detokenize{api:lateral-boundary-conditions}}\index{HorizontalBoundary (class in dycore.horizontal\_boundary)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.horizontal\_boundary.}\sphinxbfcode{HorizontalBoundary}}{\emph{grid}, \emph{nb}}{}
Abstract base class whose derived classes implement different types of horizontal boundary conditions.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
{\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.nb}]{\sphinxcrossref{\sphinxstyleliteralstrong{nb}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\end{description}\end{quote}
\index{\_\_init\_\_() (dycore.horizontal\_boundary.HorizontalBoundary method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{nb}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} or one of
its derived classes.

\item {} 
\sphinxstyleliteralstrong{nb} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{apply() (dycore.horizontal\_boundary.HorizontalBoundary method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary.apply}}\pysiglinewithargsret{\sphinxbfcode{apply}}{\emph{phi\_new}, \emph{phi\_now}}{}
Apply the boundary conditions on the field \sphinxcode{phi\_new}, possibly relying upon the solution
\sphinxcode{phi\_now} at the current time.
As this method is marked as abstract, its implementation is delegated to the derived classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} The \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} The \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{factory() (dycore.horizontal\_boundary.HorizontalBoundary static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary.factory}}\pysiglinewithargsret{\sphinxbfcode{static }\sphinxbfcode{factory}}{\emph{horizontal\_boundary\_type}, \emph{grid}, \emph{nb}}{}
Static method which returns an instance of the derived class which implements the boundary
conditions specified by \sphinxcode{horizontal\_boundary\_type}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{horizontal\_boundary\_type} (\sphinxstyleliteralemphasis{str}) \textendash{} String specifying the type of boundary conditions to apply. Either:
* ‘periodic’, for periodic boundary conditions;
* ‘relaxed’, for relaxed boundary conditions;
* ‘relaxed-symmetric-xz’, for relaxed boundary conditions for a \(xz\)-symmetric field.
* ‘relaxed-symmetric-yz’, for relaxed boundary conditions for a \(yz\)-symmetric field.

\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} or one of
its derived classes.

\item {} 
\sphinxstyleliteralstrong{nb} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\end{itemize}

\item[{Returns}] \leavevmode
An instance of derived class implementing the boundary conditions specified by \sphinxcode{horizontal\_boundary\_type}.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_computational\_to\_physical\_domain() (dycore.horizontal\_boundary.HorizontalBoundary method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary.from_computational_to_physical_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_computational\_to\_physical\_domain}}{\emph{phi\_}, \emph{out\_dims}, \emph{change\_sign}}{}
Given a \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying a stencils’ computational domain, return the associated physical
field which may (or may not) satisfy the horizontal boundary conditions.
As this method is marked as abstract, its implementation is delegated to the derived classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stencils’ computational domain.

\item {} 
\sphinxstyleliteralstrong{out\_dims} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Three-elements tuple representing the shape of the output array.

\item {} 
\sphinxstyleliteralstrong{change\_sign} (\sphinxstyleliteralemphasis{bool}) \textendash{} \sphinxcode{True} if the field should change sign through the symmetry plane,
\sphinxcode{False} otherwise.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the field defined over the physical domain.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_physical\_to\_computational\_domain() (dycore.horizontal\_boundary.HorizontalBoundary method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary.from_physical_to_computational_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_physical\_to\_computational\_domain}}{\emph{phi}}{}
Given a \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying a physical field, return the associated stencils’ computational
domain, i.e., the \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} accomodating the boundary conditions which will be input
to the stencils. If the physical and computational fields coincide, a deep copy of the physical
domain is returned.
As this method is marked as abstract, its implementation is delegated to the derived classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the physical field.

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stencils’ computational domain.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
The implementation should be designed to work with both staggered and unstaggared fields.
\end{sphinxadmonition}

\end{fulllineitems}

\index{set\_outermost\_layers\_x() (dycore.horizontal\_boundary.HorizontalBoundary method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary.set_outermost_layers_x}}\pysiglinewithargsret{\sphinxbfcode{set\_outermost\_layers\_x}}{\emph{phi\_new}, \emph{phi\_now}}{}
Set the outermost layers of \sphinxcode{phi\_new} in the \sphinxcode{x}-direction so to satisfy the lateral
boundary conditions. For this, possibly rely upon the field \sphinxcode{phi\_now} at the current time.
As this method is marked as abstract, its implementation is delegated to the derived classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_outermost\_layers\_y() (dycore.horizontal\_boundary.HorizontalBoundary method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary.set_outermost_layers_y}}\pysiglinewithargsret{\sphinxbfcode{set\_outermost\_layers\_y}}{\emph{phi\_new}, \emph{phi\_now}}{}
Set the outermost layers of \sphinxcode{phi\_new} in the \sphinxcode{y}-direction so to satisfy the lateral
boundary conditions. For this, possibly rely upon the field \sphinxcode{phi\_now} at the current time.
As this method is marked as abstract, its implementation is delegated to the derived classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Periodic (class in dycore.horizontal\_boundary)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Periodic}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.horizontal\_boundary.}\sphinxbfcode{Periodic}}{\emph{grid}, \emph{nb}}{}
This class inherits {\hyperref[\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary}]{\sphinxcrossref{\sphinxcode{HorizontalBoundary}}}} to implement horizontally periodic boundary conditions.
\index{\_\_init\_\_() (dycore.horizontal\_boundary.Periodic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Periodic.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{nb}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} or one of
its derived classes.

\item {} 
\sphinxstyleliteralstrong{nb} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{apply() (dycore.horizontal\_boundary.Periodic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Periodic.apply}}\pysiglinewithargsret{\sphinxbfcode{apply}}{\emph{phi\_new}, \emph{phi\_now=None}}{}
Apply horizontally periodic boundary conditions on \sphinxcode{phi\_new}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.
This is actually not required to apply periodic conditions, and it is retained as optional
argument only for compliancy with the class hierarchy interface.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_computational\_to\_physical\_domain() (dycore.horizontal\_boundary.Periodic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Periodic.from_computational_to_physical_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_computational\_to\_physical\_domain}}{\emph{phi\_}, \emph{out\_dims=None}, \emph{change\_sign=True}}{}
Shrink the field \sphinxcode{phi\_} by removing the \sphinxcode{nb} outermost layers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} to shrink.

\item {} 
\sphinxstyleliteralstrong{out\_dims} (\sphinxtitleref{tuple}, optional) \textendash{} Three-elements tuple representing the shape of the output array.

\item {} 
\sphinxstyleliteralstrong{change\_sign} (\sphinxtitleref{bool}, optional) \textendash{} \sphinxcode{True} if the field should change sign through the symmetry plane,
\sphinxcode{False} otherwise.

\end{itemize}

\item[{Returns}] \leavevmode
The shrunk \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_physical\_to\_computational\_domain() (dycore.horizontal\_boundary.Periodic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Periodic.from_physical_to_computational_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_physical\_to\_computational\_domain}}{\emph{phi}}{}
Periodically extend the field \sphinxcode{phi} with \sphinxcode{nb} extra layers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} to extend.

\item[{Returns}] \leavevmode
The extended \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_outermost\_layers\_x() (dycore.horizontal\_boundary.Periodic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Periodic.set_outermost_layers_x}}\pysiglinewithargsret{\sphinxbfcode{set\_outermost\_layers\_x}}{\emph{phi\_new}, \emph{phi\_now=None}}{}
Set the outermost layers of \sphinxcode{phi\_new} in the \sphinxcode{x}-direction so to satisfy the periodic
boundary conditions. For this, the field \sphinxcode{phi\_now} at the current time is not required. Yet,
it appears as (default) argument for compliancy with the general API.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_outermost\_layers\_y() (dycore.horizontal\_boundary.Periodic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Periodic.set_outermost_layers_y}}\pysiglinewithargsret{\sphinxbfcode{set\_outermost\_layers\_y}}{\emph{phi\_new}, \emph{phi\_now=None}}{}
Set the outermost layers of \sphinxcode{phi\_new} in the \sphinxcode{y}-direction so to satisfy the periodic
boundary conditions. For this, the field \sphinxcode{phi\_now} at the current time is not required. Yet,
it appears as (default) argument for compliancy with the general API.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Relaxed (class in dycore.horizontal\_boundary)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Relaxed}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.horizontal\_boundary.}\sphinxbfcode{Relaxed}}{\emph{grid}, \emph{nb}}{}
This class inherits {\hyperref[\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary}]{\sphinxcrossref{\sphinxcode{HorizontalBoundary}}}} to implement horizontally relaxed boundary conditions.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.nb}]{\sphinxcrossref{\sphinxstyleliteralstrong{nb}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\item {} 
\sphinxstyleliteralstrong{nr} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of layers which will be affected by relaxation.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (dycore.horizontal\_boundary.Relaxed method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Relaxed.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{nb}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} or one of
its derived classes.

\item {} 
\sphinxstyleliteralstrong{nb} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{apply() (dycore.horizontal\_boundary.Relaxed method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Relaxed.apply}}\pysiglinewithargsret{\sphinxbfcode{apply}}{\emph{phi\_new}, \emph{phi\_now}}{}
Apply relaxed lateral boundary conditions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
The Dirichlet conditions at the boundaries are assumed to be time-independent, so that they
can be inferred from the solution at current time.
\end{sphinxadmonition}

\end{fulllineitems}

\index{from\_computational\_to\_physical\_domain() (dycore.horizontal\_boundary.Relaxed method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Relaxed.from_computational_to_physical_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_computational\_to\_physical\_domain}}{\emph{phi\_}, \emph{out\_dims=None}, \emph{change\_sign=True}}{}
As no extension is required to apply relaxed boundary conditions, return a deep copy of the
input field \sphinxcode{phi\_}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} A \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}}.

\item {} 
\sphinxstyleliteralstrong{out\_dims} (\sphinxtitleref{tuple}, optional) \textendash{} Three-elements tuple representing the shape of the output array.

\item {} 
\sphinxstyleliteralstrong{change\_sign} (\sphinxtitleref{bool}, optional) \textendash{} \sphinxcode{True} if the field should change sign through the symmetry plane,
\sphinxcode{False} otherwise.

\end{itemize}

\item[{Returns}] \leavevmode
A deep copy of \sphinxcode{phi\_}.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_physical\_to\_computational\_domain() (dycore.horizontal\_boundary.Relaxed method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Relaxed.from_physical_to_computational_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_physical\_to\_computational\_domain}}{\emph{phi}}{}
As no extension is required to apply relaxed boundary conditions, return a deep copy of the
input field \sphinxcode{phi}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} A \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}}.

\item[{Returns}] \leavevmode
A deep copy of \sphinxcode{phi}.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_outermost\_layers\_x() (dycore.horizontal\_boundary.Relaxed method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Relaxed.set_outermost_layers_x}}\pysiglinewithargsret{\sphinxbfcode{set\_outermost\_layers\_x}}{\emph{phi\_new}, \emph{phi\_now}}{}
Set the outermost layers of \sphinxcode{phi\_new} in the \sphinxcode{x}-direction equal to the corresponding
layers of \sphinxcode{phi\_now}. In other words, apply Dirichlet conditions in \sphinxcode{x}-direction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_outermost\_layers\_y() (dycore.horizontal\_boundary.Relaxed method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.Relaxed.set_outermost_layers_y}}\pysiglinewithargsret{\sphinxbfcode{set\_outermost\_layers\_y}}{\emph{phi\_new}, \emph{phi\_now}}{}
Set the outermost layers of \sphinxcode{phi\_new} in the \sphinxcode{y}-direction equal to the corresponding
layers of \sphinxcode{phi\_now}. In other words, apply Dirichelt conditions in \sphinxcode{y}-direction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi\_new} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} on which applying the boundary conditions.

\item {} 
\sphinxstyleliteralstrong{phi\_now} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} representing the field at the current time.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RelaxedSymmetricXZ (class in dycore.horizontal\_boundary)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.RelaxedSymmetricXZ}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.horizontal\_boundary.}\sphinxbfcode{RelaxedSymmetricXZ}}{\emph{grid}, \emph{nb}}{}
This class inherits {\hyperref[\detokenize{api:dycore.horizontal_boundary.Relaxed}]{\sphinxcrossref{\sphinxcode{Relaxed}}}} to implement horizontally relaxed boundary conditions
for fields symmetric with respect to the \(xz\)-plane \(y = y_c = 0.5 (a_y + b_y)\),
where \(a_y\) and \(b_y\) denote the extremes of the domain in the \(y\)-direction.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.nb}]{\sphinxcrossref{\sphinxstyleliteralstrong{nb}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\item {} 
\sphinxstyleliteralstrong{nr} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of layers which will be affected by relaxation.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (dycore.horizontal\_boundary.RelaxedSymmetricXZ method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.RelaxedSymmetricXZ.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{nb}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} or one of
its derived classes.

\item {} 
\sphinxstyleliteralstrong{nb} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_computational\_to\_physical\_domain() (dycore.horizontal\_boundary.RelaxedSymmetricXZ method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.RelaxedSymmetricXZ.from_computational_to_physical_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_computational\_to\_physical\_domain}}{\emph{phi\_}, \emph{out\_dims}, \emph{change\_sign=False}}{}
Mirror the computational domain with respect to the \(xz\)-plane \(y = y_c\).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stencils’ computational domain.

\item {} 
\sphinxstyleliteralstrong{out\_dims} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Three-elements tuple representing the shape of the output array.

\item {} 
\sphinxstyleliteralstrong{change\_sign} (\sphinxtitleref{bool}, optional) \textendash{} \sphinxcode{True} if the field should change sign through the
symmetry plane, \sphinxcode{False} otherwise. Default is \sphinxcode{False}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the associated physical field.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_physical\_to\_computational\_domain() (dycore.horizontal\_boundary.RelaxedSymmetricXZ method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.RelaxedSymmetricXZ.from_physical_to_computational_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_physical\_to\_computational\_domain}}{\emph{phi}}{}
Return the \(y\)-lowermost half of the domain. To accomodate symmetric conditions,
we retain (at least) \sphinxcode{nb} additional layers in the positive direction of the \(y\)-axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the physical field.

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stencils’ computational domain.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RelaxedSymmetricYZ (class in dycore.horizontal\_boundary)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.RelaxedSymmetricYZ}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.horizontal\_boundary.}\sphinxbfcode{RelaxedSymmetricYZ}}{\emph{grid}, \emph{nb}}{}
This class inherits {\hyperref[\detokenize{api:dycore.horizontal_boundary.Relaxed}]{\sphinxcrossref{\sphinxcode{Relaxed}}}} to implement horizontally relaxed boundary conditions
for fields symmetric with respect to the \(yz\)-plane \(x = x_c = 0.5 (a_x + b_x)\),
where \(a_x\) and \(b_x\) denote the extremes of the domain in the \(x\)-direction.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.nb}]{\sphinxcrossref{\sphinxstyleliteralstrong{nb}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\item {} 
\sphinxstyleliteralstrong{nr} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of layers which will be affected by relaxation.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (dycore.horizontal\_boundary.RelaxedSymmetricYZ method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.RelaxedSymmetricYZ.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{nb}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} or one of
its derived classes.

\item {} 
\sphinxstyleliteralstrong{nb} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of boundary layers.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_computational\_to\_physical\_domain() (dycore.horizontal\_boundary.RelaxedSymmetricYZ method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.RelaxedSymmetricYZ.from_computational_to_physical_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_computational\_to\_physical\_domain}}{\emph{phi\_}, \emph{out\_dims}, \emph{change\_sign=False}}{}
Mirror the computational domain with respect to the \(yz\)-axis \(x = x_c\).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stencils’ computational domain.

\item {} 
\sphinxstyleliteralstrong{out\_dims} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Three-elements tuple representing the shape of the output array.

\item {} 
\sphinxstyleliteralstrong{change\_sign} (\sphinxtitleref{bool}, optional) \textendash{} \sphinxcode{True} if the field should change sign through the
symmetry plane, \sphinxcode{False} otherwise. Default is obj:\sphinxtitleref{False}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the associated physical field.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_physical\_to\_computational\_domain() (dycore.horizontal\_boundary.RelaxedSymmetricYZ method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.horizontal_boundary.RelaxedSymmetricYZ.from_physical_to_computational_domain}}\pysiglinewithargsret{\sphinxbfcode{from\_physical\_to\_computational\_domain}}{\emph{phi}}{}
Return the \(x\)-lowermost half of the domain. To accomodate symmetric conditions,
we retain (at least) \sphinxcode{nb} additional layers in the positive direction of the \(x\)-axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the physical field.

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stencils’ computational domain.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Numerical diffusion}
\label{\detokenize{api:numerical-diffusion}}\index{Diffusion (class in dycore.diffusion)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.diffusion.Diffusion}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.diffusion.}\sphinxbfcode{Diffusion}}{\emph{grid}, \emph{idamp=True}, \emph{damp\_depth=10}, \emph{diff\_coeff=0.03}, \emph{diff\_max=0.24}, \emph{backend=\textless{}Mode.NUMPY: 4\textgreater{}}}{}
Class applying horizontal numerical diffusion to a generic (prognostic) variable by means of a GT4Py’s stencil.
\index{\_\_init\_\_() (dycore.diffusion.Diffusion method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.diffusion.Diffusion.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{idamp=True}, \emph{damp\_depth=10}, \emph{diff\_coeff=0.03}, \emph{diff\_max=0.24}, \emph{backend=\textless{}Mode.NUMPY: 4\textgreater{}}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} or one of its
derived classes.

\item {} 
\sphinxstyleliteralstrong{idamp} (\sphinxtitleref{bool}, optional) \textendash{} \sphinxcode{True} if vertical damping is enabled, \sphinxcode{False} otherwise.
In the former situation, the diffusion coefficient is monotonically increased towards the
top of the domain, thus to mimic the effect of a wave absorber.

\item {} 
\sphinxstyleliteralstrong{damp\_depth} (\sphinxtitleref{int}, optional) \textendash{} Depth of the damping region, i.e., number of vertical layers
within the damping region. Default is 10.

\item {} 
\sphinxstyleliteralstrong{diff\_coeff} (\sphinxtitleref{float}, optional) \textendash{} Value for the diffusion coefficient far from the top boundary.
Default is 0.03.

\item {} 
\sphinxstyleliteralstrong{diff\_max} (\sphinxtitleref{float}, optional) \textendash{} Maximum value for the diffusion coefficient. For the sake of numerical
stability, it should not exceed 0.25. Default is 0.24.

\item {} 
\sphinxstyleliteralstrong{backend} (\sphinxtitleref{obj}, optional) \textendash{} \sphinxcode{gridtools.mode} specifying the backend for the GT4Py’s stencil
implementing numerical diffusion. Default is \sphinxcode{gridtools.mode.NUMPY}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{apply() (dycore.diffusion.Diffusion method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.diffusion.Diffusion.apply}}\pysiglinewithargsret{\sphinxbfcode{apply}}{\emph{phi}}{}
Apply horizontal diffusion to a field \(phi\).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{phi} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} The field \(phi\) as a \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}}.

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} storing the diffused field.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Numerical fluxes}
\label{\detokenize{api:numerical-fluxes}}\index{IsentropicFlux (class in dycore.isentropic\_flux)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.IsentropicFlux}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.isentropic\_flux.}\sphinxbfcode{IsentropicFlux}}{\emph{grid}, \emph{imoist}}{}
Abstract base class whose derived classes implement different schemes for computing the numerical fluxes for
the three-dimensional isentropic dynamical core.
\index{\_\_init\_\_() (dycore.isentropic\_flux.IsentropicFlux method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.IsentropicFlux.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{imoist}}{}
Constructor.

Arguments:

\end{fulllineitems}

\index{factory() (dycore.isentropic\_flux.IsentropicFlux static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.IsentropicFlux.factory}}\pysiglinewithargsret{\sphinxbfcode{static }\sphinxbfcode{factory}}{\emph{scheme}, \emph{grid}, \emph{imoist}}{}
Static method which returns an instance of the derived class implementing the numerical scheme
specified by \sphinxcode{scheme}.

\end{fulllineitems}

\index{get\_fluxes() (dycore.isentropic\_flux.IsentropicFlux method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.IsentropicFlux.get_fluxes}}\pysiglinewithargsret{\sphinxbfcode{get\_fluxes}}{\emph{i}, \emph{j}, \emph{k}, \emph{dt}, \emph{s}, \emph{u}, \emph{v}, \emph{mtg}, \emph{U}, \emph{V}, \emph{Qv=None}, \emph{Qc=None}, \emph{Qr=None}}{}
The entry-point method to the class.

\end{fulllineitems}


\end{fulllineitems}

\index{UpwindIsentropicFlux (class in dycore.isentropic\_flux)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.UpwindIsentropicFlux}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.isentropic\_flux.}\sphinxbfcode{UpwindIsentropicFlux}}{\emph{grid}, \emph{imoist}}{}
Class which inherits {\hyperref[\detokenize{api:dycore.isentropic_flux.IsentropicFlux}]{\sphinxcrossref{\sphinxcode{IsentropicFlux}}}} to implement the upwind scheme.
\index{\_\_init\_\_() (dycore.isentropic\_flux.UpwindIsentropicFlux method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.UpwindIsentropicFlux.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{imoist}}{}
Constructor.

\end{fulllineitems}


\end{fulllineitems}

\index{LeapfrogIsentropicFlux (class in dycore.isentropic\_flux)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.LeapfrogIsentropicFlux}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.isentropic\_flux.}\sphinxbfcode{LeapfrogIsentropicFlux}}{\emph{grid}, \emph{imoist}}{}
Class which inherits {\hyperref[\detokenize{api:dycore.isentropic_flux.IsentropicFlux}]{\sphinxcrossref{\sphinxcode{IsentropicFlux}}}} to implement the leapfrog scheme.
\index{\_\_init\_\_() (dycore.isentropic\_flux.LeapfrogIsentropicFlux method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.LeapfrogIsentropicFlux.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{imoist}}{}
Constructor.

\end{fulllineitems}


\end{fulllineitems}

\index{MacCormackIsentropicFlux (class in dycore.isentropic\_flux)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.MacCormackIsentropicFlux}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.isentropic\_flux.}\sphinxbfcode{MacCormackIsentropicFlux}}{\emph{grid}, \emph{imoist}}{}
Class which inherits {\hyperref[\detokenize{api:dycore.isentropic_flux.IsentropicFlux}]{\sphinxcrossref{\sphinxcode{IsentropicFlux}}}} to implement the MacCormack scheme.
\index{\_\_init\_\_() (dycore.isentropic\_flux.MacCormackIsentropicFlux method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_flux.MacCormackIsentropicFlux.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{imoist}}{}
Constructor.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Prognostics}
\label{\detokenize{api:prognostics}}\index{IsentropicPrognostic (class in dycore.isentropic\_prognostic)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.isentropic\_prognostic.}\sphinxbfcode{IsentropicPrognostic}}{\emph{grid}, \emph{imoist}, \emph{scheme}, \emph{backend}}{}
Abstract base class whose derived classes implement different schemes to carry out the
prognostic step of the three-dimensional moist isentropic dynamical core.
\index{\_\_init\_\_() (dycore.isentropic\_prognostic.IsentropicPrognostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{imoist}, \emph{scheme}, \emph{backend}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}}.

\item {} 
\sphinxstyleliteralstrong{imoist} (\sphinxstyleliteralemphasis{bool}) \textendash{} \sphinxcode{True} for a moisture dynamical core, \sphinxcode{False} otherwise.

\item {} 
\sphinxstyleliteralstrong{scheme} (\sphinxstyleliteralemphasis{str}) \textendash{} String specifying the scheme to use. Either:
* ‘upwind’, for the upwind scheme;
* ‘leapfrog’, for the leapfrog scheme;
* ‘maccormack’, for the MacCormack scheme.

\item {} 
\sphinxstyleliteralstrong{backend} (\sphinxstyleliteralemphasis{obj}) \textendash{} GT4Py’s backend, of class \sphinxcode{gridtools.mode}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{factory() (dycore.isentropic\_prognostic.IsentropicPrognostic static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.factory}}\pysiglinewithargsret{\sphinxbfcode{static }\sphinxbfcode{factory}}{\emph{grid}, \emph{imoist}, \emph{scheme}, \emph{backend}}{}
Static method returning an instace of the derived class implementing the scheme specified by
\sphinxcode{scheme}.

\end{fulllineitems}

\index{nb (dycore.isentropic\_prognostic.IsentropicPrognostic attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.nb}}\pysigline{\sphinxbfcode{nb}}
\sphinxstyleemphasis{Get the number of boundary layers} \textendash{}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{int} representing the number of boundary layers.

\end{description}\end{quote}

\end{fulllineitems}

\index{step\_forward() (dycore.isentropic\_prognostic.IsentropicPrognostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.step_forward}}\pysiglinewithargsret{\sphinxbfcode{step\_forward}}{\emph{diagnostic}, \emph{boundary}, \emph{dt}, \emph{s}, \emph{u}, \emph{v}, \emph{p}, \emph{mtg}, \emph{U}, \emph{V}, \emph{Qv=None}, \emph{Qc=None}, \emph{Qr=None}, \emph{old\_s=None}, \emph{old\_U=None}, \emph{old\_V=None}, \emph{old\_Qv=None}, \emph{old\_Qc=None}, \emph{old\_Qr=None}}{}
Method moving the conservative model variables one time step forward.
As this method is marked as abstract, its implementation is delegated to the derived classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{diagnostic} (\sphinxstyleliteralemphasis{obj}) \textendash{} An instance of {\hyperref[\detokenize{api:dycore.isentropic_diagnostic.IsentropicDiagnostic}]{\sphinxcrossref{\sphinxcode{IsentropicDiagnostic}}}}.

\item {} 
\sphinxstyleliteralstrong{boundary} (\sphinxstyleliteralemphasis{obj}) \textendash{} An instance of one of the derived classes of {\hyperref[\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary}]{\sphinxcrossref{\sphinxcode{HorizontalBoundary}}}},
implementing the lateral boundary conditions.

\item {} 
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{obj}) \textendash{} A \sphinxcode{datetime.timedelta} representing the time step.

\item {} 
\sphinxstyleliteralstrong{s} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the isentropic density at current time.

\item {} 
\sphinxstyleliteralstrong{u} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-velocity at current time.

\item {} 
\sphinxstyleliteralstrong{v} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-velocity at current time.

\item {} 
\sphinxstyleliteralstrong{p} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the pressure at current time.

\item {} 
\sphinxstyleliteralstrong{mtg} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the Montgomery potential at current time.

\item {} 
\sphinxstyleliteralstrong{U} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-momentum at current time.

\item {} 
\sphinxstyleliteralstrong{V} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-momentum at current time.

\item {} 
\sphinxstyleliteralstrong{Qv} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_v\) at current time.

\item {} 
\sphinxstyleliteralstrong{Qc} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_c\) at current time.

\item {} 
\sphinxstyleliteralstrong{Qr} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_r\) at current time.

\item {} 
\sphinxstyleliteralstrong{old\_s} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the isentropic density at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_U} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-momentum at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_V} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-momentum at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qv} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_v\) at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qc} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_c\) at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qr} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_r\) at the previous time step.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped isentropic density.
out\_U (array\_like): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(x\)-momentum.
out\_V (array\_like): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(y\)-momentum.
out\_Qv (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_v\).
out\_Qc (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_c\).
out\_Qr (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_r\).

\item[{Return type}] \leavevmode
out\_s (array\_like)

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
All the input arrays are supposed to have been properly extended to accomodate the
horizontal boundary conditions.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{OneTimeLevelIsentropicPrognostic (class in dycore.isentropic\_prognostic)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.OneTimeLevelIsentropicPrognostic}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.isentropic\_prognostic.}\sphinxbfcode{OneTimeLevelIsentropicPrognostic}}{\emph{grid}, \emph{imoist}, \emph{scheme}, \emph{backend}}{}
This class inherits {\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic}]{\sphinxcrossref{\sphinxcode{IsentropicPrognostic}}}} to implement
a standard one-time-level scheme carrying out the prognostic step of the three-dimensional
moist isentropic dynamical core.
\index{\_\_init\_\_() (dycore.isentropic\_prognostic.OneTimeLevelIsentropicPrognostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.OneTimeLevelIsentropicPrognostic.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{imoist}, \emph{scheme}, \emph{backend}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}}.

\item {} 
\sphinxstyleliteralstrong{imoist} (\sphinxstyleliteralemphasis{bool}) \textendash{} \sphinxcode{True} for a moisture dynamical core, \sphinxcode{False} otherwise.

\item {} 
\sphinxstyleliteralstrong{scheme} (\sphinxstyleliteralemphasis{str}) \textendash{} String specifying the scheme to use. Either:
* ‘upwind’, for the upwind scheme;
* ‘maccormack’, for the MacCormack scheme.

\item {} 
\sphinxstyleliteralstrong{backend} (\sphinxstyleliteralemphasis{obj}) \textendash{} GT4Py’s backend, of class \sphinxcode{gridtools.mode}.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
To instantiate an object of this class, one should prefer the static method
{\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.factory}]{\sphinxcrossref{\sphinxcode{factory()}}}} of
{\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic}]{\sphinxcrossref{\sphinxcode{IsentropicPrognostic}}}}.
\end{sphinxadmonition}

\end{fulllineitems}

\index{step\_forward() (dycore.isentropic\_prognostic.OneTimeLevelIsentropicPrognostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.OneTimeLevelIsentropicPrognostic.step_forward}}\pysiglinewithargsret{\sphinxbfcode{step\_forward}}{\emph{diagnostic}, \emph{boundary}, \emph{dt}, \emph{s}, \emph{u}, \emph{v}, \emph{p}, \emph{mtg}, \emph{U}, \emph{V}, \emph{Qv=None}, \emph{Qc=None}, \emph{Qr=None}, \emph{old\_s=None}, \emph{old\_U=None}, \emph{old\_V=None}, \emph{old\_Qv=None}, \emph{old\_Qc=None}, \emph{old\_Qr=None}}{}
Method moving the conservative model variables one time step forward.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{diagnostic} (\sphinxstyleliteralemphasis{obj}) \textendash{} An instance of {\hyperref[\detokenize{api:dycore.isentropic_diagnostic.IsentropicDiagnostic}]{\sphinxcrossref{\sphinxcode{IsentropicDiagnostic}}}}.

\item {} 
\sphinxstyleliteralstrong{boundary} (\sphinxstyleliteralemphasis{obj}) \textendash{} An instance of one of the derived classes of {\hyperref[\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary}]{\sphinxcrossref{\sphinxcode{HorizontalBoundary}}}},
implementing the lateral boundary conditions.

\item {} 
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{obj}) \textendash{} A \sphinxcode{datetime.timedelta} representing the time step.

\item {} 
\sphinxstyleliteralstrong{s} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the isentropic density at current time.

\item {} 
\sphinxstyleliteralstrong{u} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-velocity at current time.

\item {} 
\sphinxstyleliteralstrong{v} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-velocity at current time.

\item {} 
\sphinxstyleliteralstrong{p} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the pressure at current time.

\item {} 
\sphinxstyleliteralstrong{mtg} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the Montgomery potential at current time.

\item {} 
\sphinxstyleliteralstrong{U} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-momentum at current time.

\item {} 
\sphinxstyleliteralstrong{V} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-momentum at current time.

\item {} 
\sphinxstyleliteralstrong{Qv} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_v\) at current time.

\item {} 
\sphinxstyleliteralstrong{Qc} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_c\) at current time.

\item {} 
\sphinxstyleliteralstrong{Qr} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_r\) at current time.

\item {} 
\sphinxstyleliteralstrong{old\_s} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the isentropic density at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_U} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-momentum at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_V} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-momentum at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qv} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_v\) at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qc} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_c\) at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qr} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_r\) at the previous time step.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped isentropic density.
out\_U (array\_like): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(x\)-momentum.
out\_V (array\_like): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(y\)-momentum.
out\_Qv (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_v\).
out\_Qc (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_c\).
out\_Qr (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_r\).

\item[{Return type}] \leavevmode
out\_s (array\_like)

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
All the input arrays are supposed to have been properly extended/mirrored to accomodate the
horizontal boundary conditions. In other terms, they should be computational domains, rather
than physical fields.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{TwoTimeLevelsIsentropicPrognostic (class in dycore.isentropic\_prognostic)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.TwoTimeLevelsIsentropicPrognostic}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.isentropic\_prognostic.}\sphinxbfcode{TwoTimeLevelsIsentropicPrognostic}}{\emph{grid}, \emph{imoist}, \emph{scheme}, \emph{backend}}{}
This class inherits {\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic}]{\sphinxcrossref{\sphinxcode{IsentropicPrognostic}}}} to
implement a standard two-time-levels scheme carrying out the prognostic step of the three-dimensional
moist isentropic dynamical core. An example of this kind of schemes is the leapfrog scheme.
\index{\_\_init\_\_() (dycore.isentropic\_prognostic.TwoTimeLevelsIsentropicPrognostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.TwoTimeLevelsIsentropicPrognostic.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{imoist}, \emph{scheme}, \emph{backend}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The underlying grid, as an instance of {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}}.

\item {} 
\sphinxstyleliteralstrong{imoist} (\sphinxstyleliteralemphasis{bool}) \textendash{} \sphinxcode{True} for a moisture dynamical core, \sphinxcode{False} otherwise.

\item {} 
\sphinxstyleliteralstrong{scheme} (\sphinxstyleliteralemphasis{str}) \textendash{} String specifying the scheme to use. Either:
* ‘leapfrog’, for the leapfrog scheme.

\item {} 
\sphinxstyleliteralstrong{backend} (\sphinxstyleliteralemphasis{obj}) \textendash{} GT4Py’s backend, of class \sphinxcode{gridtools.mode}.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
To instantiate an object of this class, one should prefer the static method
{\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic.factory}]{\sphinxcrossref{\sphinxcode{factory()}}}} of
{\hyperref[\detokenize{api:dycore.isentropic_prognostic.IsentropicPrognostic}]{\sphinxcrossref{\sphinxcode{IsentropicPrognostic}}}}.
\end{sphinxadmonition}

\end{fulllineitems}

\index{step\_forward() (dycore.isentropic\_prognostic.TwoTimeLevelsIsentropicPrognostic method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.isentropic_prognostic.TwoTimeLevelsIsentropicPrognostic.step_forward}}\pysiglinewithargsret{\sphinxbfcode{step\_forward}}{\emph{boundary}, \emph{diagnostic}, \emph{dt}, \emph{s}, \emph{u}, \emph{v}, \emph{p}, \emph{mtg}, \emph{U}, \emph{V}, \emph{Qv=None}, \emph{Qc=None}, \emph{Qr=None}, \emph{old\_s=None}, \emph{old\_U=None}, \emph{old\_V=None}, \emph{old\_Qv=None}, \emph{old\_Qc=None}, \emph{old\_Qr=None}}{}
Method moving the conservative model variables one time step forward.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{diagnostic} (\sphinxstyleliteralemphasis{obj}) \textendash{} An instance of {\hyperref[\detokenize{api:dycore.isentropic_diagnostic.IsentropicDiagnostic}]{\sphinxcrossref{\sphinxcode{IsentropicDiagnostic}}}}.

\item {} 
\sphinxstyleliteralstrong{boundary} (\sphinxstyleliteralemphasis{obj}) \textendash{} An instance of one of the derived classes of {\hyperref[\detokenize{api:dycore.horizontal_boundary.HorizontalBoundary}]{\sphinxcrossref{\sphinxcode{HorizontalBoundary}}}},
implementing the lateral boundary conditions.

\item {} 
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{obj}) \textendash{} A \sphinxcode{datetime.timedelta} representing the time step.

\item {} 
\sphinxstyleliteralstrong{s} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the isentropic density at current time.

\item {} 
\sphinxstyleliteralstrong{u} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-velocity at current time.

\item {} 
\sphinxstyleliteralstrong{v} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-velocity at current time.

\item {} 
\sphinxstyleliteralstrong{p} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the pressure at current time.

\item {} 
\sphinxstyleliteralstrong{mtg} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the Montgomery potential at current time.

\item {} 
\sphinxstyleliteralstrong{U} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-momentum at current time.

\item {} 
\sphinxstyleliteralstrong{V} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-momentum at current time.

\item {} 
\sphinxstyleliteralstrong{Qv} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_v\) at current time.

\item {} 
\sphinxstyleliteralstrong{Qc} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_c\) at current time.

\item {} 
\sphinxstyleliteralstrong{Qr} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_r\) at current time.

\item {} 
\sphinxstyleliteralstrong{old\_s} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the isentropic density at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_U} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(x\)-momentum at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_V} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the \(y\)-momentum at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qv} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_v\) at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qc} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_c\) at the previous time step.

\item {} 
\sphinxstyleliteralstrong{old\_Qr} (\sphinxtitleref{array\_like}, optional) \textendash{} \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying \(Q_r\) at the previous time step.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped isentropic density.
out\_U (array\_like): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(x\)-momentum.
out\_V (array\_like): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(y\)-momentum.
out\_Qv (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_v\).
out\_Qc (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_c\).
out\_Qr (\sphinxtitleref{array\_like}, optional): \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the stepped \(Q_r\).

\item[{Return type}] \leavevmode
out\_s (array\_like)

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
All the input arrays are supposed to have been properly extended to accomodate the
horizontal boundary conditions.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Wave absorber}
\label{\detokenize{api:wave-absorber}}\index{VerticalDamping (class in dycore.vertical\_damping)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.vertical_damping.VerticalDamping}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.vertical\_damping.}\sphinxbfcode{VerticalDamping}}{\emph{grid}, \emph{damp\_depth}, \emph{damp\_max}, \emph{backend}}{}
Abstract base class whose derived classes implement different vertical damping, i.e., wave absorbing, techniques.
\index{\_\_init\_\_() (dycore.vertical\_damping.VerticalDamping method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.vertical_damping.VerticalDamping.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{damp\_depth}, \emph{damp\_max}, \emph{backend}}{}
Constructor.

\end{fulllineitems}

\index{apply() (dycore.vertical\_damping.VerticalDamping method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.vertical_damping.VerticalDamping.apply}}\pysiglinewithargsret{\sphinxbfcode{apply}}{\emph{dt}, \emph{phi\_now}, \emph{phi\_new}, \emph{phi\_ref}}{}
Apply the vertical damping to the field \(phi\). As this method is marked as abstract,
its implementation is delegated to the derived classes.

\end{fulllineitems}

\index{factory() (dycore.vertical\_damping.VerticalDamping static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.vertical_damping.VerticalDamping.factory}}\pysiglinewithargsret{\sphinxbfcode{static }\sphinxbfcode{factory}}{\emph{damp\_type}, \emph{grid}, \emph{damp\_depth}, \emph{damp\_max}, \emph{backend}}{}
Static method which returns an instance of the derived class implementing the damping method
specified by \sphinxcode{damp\_type}.

\end{fulllineitems}


\end{fulllineitems}

\index{Rayleigh (class in dycore.vertical\_damping)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.vertical_damping.Rayleigh}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{dycore.vertical\_damping.}\sphinxbfcode{Rayleigh}}{\emph{grid}, \emph{damp\_depth}, \emph{damp\_max}, \emph{backend}}{}
This class inherits {\hyperref[\detokenize{api:dycore.vertical_damping.VerticalDamping}]{\sphinxcrossref{\sphinxcode{VerticalDamping}}}} to implement a Rayleigh absorber.
\index{\_\_init\_\_() (dycore.vertical\_damping.Rayleigh method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.vertical_damping.Rayleigh.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{damp\_depth}, \emph{damp\_max}, \emph{backend}}{}
Constructor.

\end{fulllineitems}

\index{apply() (dycore.vertical\_damping.Rayleigh method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:dycore.vertical_damping.Rayleigh.apply}}\pysiglinewithargsret{\sphinxbfcode{apply}}{\emph{dt}, \emph{phi\_now}, \emph{phi\_new}, \emph{phi\_ref}}{}
Apply the vertical damping to the field \(phi\).

\end{fulllineitems}


\end{fulllineitems}



\section{Grids}
\label{\detokenize{api:grids}}

\subsection{Two-dimensional grids}
\label{\detokenize{api:two-dimensional-grids}}\index{XYGrid (class in grids.xy\_grid)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xy_grid.XYGrid}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.xy\_grid.}\sphinxbfcode{XYGrid}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}}{}
Rectangular and regular two-dimensional grid embedded in a reference system whose
coordinates are, in the order, \(x\) and \(y\). No assumption is made on
the nature of the coordinates. For instance, \(x\) may be the longitude, in
which case \(x \equiv \lambda\), and \(y\) may be the latitude, in which
case \(y \equiv \phi\).
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x}]{\sphinxcrossref{\sphinxstyleliteralstrong{x}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(x\) main levels.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x_half_levels}]{\sphinxcrossref{\sphinxstyleliteralstrong{x\_half\_levels}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(x\) half levels.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dx}]{\sphinxcrossref{\sphinxstyleliteralstrong{dx}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(x\)-spacing.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.y}]{\sphinxcrossref{\sphinxstyleliteralstrong{y}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(y\) main levels.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.y_half_levels}]{\sphinxcrossref{\sphinxstyleliteralstrong{y\_half\_levels}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(y\) half levels.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.ny}]{\sphinxcrossref{\sphinxstyleliteralstrong{ny}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(y\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dy}]{\sphinxcrossref{\sphinxstyleliteralstrong{dy}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(y\)-spacing.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.xy\_grid.XYGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xy_grid.XYGrid.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{start}, ~ x_{stop})\).

\item {} 
\sphinxstyleliteralstrong{nx} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
\sphinxstyleliteralstrong{domain\_y} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((y_{start}, ~ y_{stop})\).

\item {} 
\sphinxstyleliteralstrong{ny} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(y\).

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} Units for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{units\_y} (\sphinxtitleref{str}, optional) \textendash{} Units for the \(y\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{dims\_y} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(y\)-coordinate.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Axes labels should use the \sphinxhref{http://cfconventions.org}{CF Conventions}.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{XZGrid (class in grids.xz\_grid)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xz_grid.XZGrid}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.xz\_grid.}\sphinxbfcode{XZGrid}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='m'}, \emph{dims\_x='x'}, \emph{units\_z='m'}, \emph{dims\_z='z'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Rectangular and regular two-dimensional grid embedded in a reference system whose
coordinates are
\begin{itemize}
\item {} 
the horizontal coordinate \(x\), and

\item {} 
the vertical (terrain-following) coordinate \(z\).

\end{itemize}

The vertical coordinate \(z\) may be formulated to define a hybrid terrain-
following coordinate system with terrain-following coordinate lines between the
surface terrain-height and \(z = z_F\), where \(z\)-coordinate lines change
back to flat horizontal lines. However, no assumption is made on the actual nature
of \(z\) which may be either pressure-based or height-based.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x}]{\sphinxcrossref{\sphinxstyleliteralstrong{x}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(x\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dx}]{\sphinxcrossref{\sphinxstyleliteralstrong{dx}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(x\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(z\)-main levels.

\item {} 
\sphinxstyleliteralstrong{z\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(z\)-half levels.

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{dz} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(z\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} The interface coordinate \(z_F\).

\item {} 
{\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxstyleliteralstrong{topography}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.topography.Topography1d}]{\sphinxcrossref{\sphinxcode{Topography1d}}}} object representing
the topography.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
For the sake of compliancy with the \sphinxhref{http://www.cosmo-model.org}{COSMO model},
the vertical grid points are ordered from the top of the domain to the surface.
\end{sphinxadmonition}
\index{\_\_init\_\_() (grids.xz\_grid.XZGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xz_grid.XZGrid.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='m'}, \emph{dims\_x='x'}, \emph{units\_z='m'}, \emph{dims\_z='z'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{left}, ~ x_{right})\).

\item {} 
\sphinxstyleliteralstrong{nx} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(x\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_z} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((z_{top}, ~ z_{surface})\).

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(x\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{units\_z} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(z\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_z} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(z\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxtitleref{float}, optional) \textendash{} Interface value \(z_F\). If not specified,
it is assumed that \(z_F = z_T\), with \(z_T\) the value of \(z\)
at the top of the domain. In other words, a fully terrain-following coordinate
system is supposed.

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}}
for further details.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxtitleref{float}, optional) \textendash{} Simulation time (in seconds) at which the topography
should stop increasing. Default is 0, corresponding to a time-invariant terrain
surface-height. See \sphinxcode{gridis.topography} for further details.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} keyword arguments to be forwarded to the constructor of
{\hyperref[\detokenize{api:grids.topography.Topography1d}]{\sphinxcrossref{\sphinxcode{Topography1d}}}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_topography() (grids.xz\_grid.XZGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xz_grid.XZGrid.update_topography}}\pysiglinewithargsret{\sphinxbfcode{update\_topography}}{\emph{time}}{}
Update the (time-dependent) topography.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{float}) \textendash{} Current simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Sigma2d (class in grids.sigma)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sigma.Sigma2d}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.sigma.}\sphinxbfcode{Sigma2d}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='m'}, \emph{dims\_x='x'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=datetime.timedelta(0)}, \emph{**kwargs}}{}
This class inherits {\hyperref[\detokenize{api:grids.xz_grid.XZGrid}]{\sphinxcrossref{\sphinxcode{XZGrid}}}} to represent a rectangular and regular
two-dimensional grid embedded in a reference system whose coordinates are
\begin{itemize}
\item {} 
the horizontal coordinate \(x\), and

\item {} 
the pressure-based terrain-following coordinate \(\sigma = p / p_{SL}\),                  where \(p\) is the pressure and \(p_{SL}\) the pressure at the                  sea level.

\end{itemize}

The vertical coordinate \(\sigma\) may be formulated to define a hybrid terrain-
following coordinate system with terrain-following coordinate lines between the
surface terrain-height and \(\sigma = \sigma_F\), where \(\sigma\)-coordinate
lines change back to flat horizontal lines.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x}]{\sphinxcrossref{\sphinxstyleliteralstrong{x}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(x\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dx}]{\sphinxcrossref{\sphinxstyleliteralstrong{dx}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(x\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(\sigma\)-main levels.

\item {} 
\sphinxstyleliteralstrong{z\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(\sigma\)-half levels.

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{dz} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(\sigma\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} The interface coordinate \(\sigma_F\).

\item {} 
{\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxstyleliteralstrong{topography}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.topography.Topography1d}]{\sphinxcrossref{\sphinxcode{Topography1d}}}} object representing
the topography.

\item {} 
\sphinxstyleliteralstrong{height} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{height\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the half levels.

\item {} 
\sphinxstyleliteralstrong{height\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} geometrical height corresponding to \(\sigma = \sigma_F\).

\item {} 
\sphinxstyleliteralstrong{reference\_pressure} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{reference\_pressure\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical
height at the half levels.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.sigma.Sigma2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sigma.Sigma2d.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='m'}, \emph{dims\_x='x'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=datetime.timedelta(0)}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{left}, ~ x_{right})\).

\item {} 
\sphinxstyleliteralstrong{nx} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(x\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_z} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((\sigma_{top}, ~ \sigma_{surface})\).

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(x\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxtitleref{float}, optional) \textendash{} Interface value \(\sigma_F\). If not specified,
it is assumed that \(\sigma_F = \sigma_T\), with \(\sigma_T\) the value
of \(\sigma\) at the top of the domain. In other words, a fully terrain-following
coordinate system is supposed.

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}}
for further details.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxtitleref{float}, optional) \textendash{} Simulation time (in seconds) at which the topography
should stop increasing. Default is 0, corresponding to a time-invariant terrain
surface-height. See \sphinxcode{gridis.topography} for further details.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} keyword arguments to be forwarded to the constructor of
{\hyperref[\detokenize{api:grids.topography.Topography1d}]{\sphinxcrossref{\sphinxcode{Topography1d}}}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (grids.sigma.Sigma2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sigma.Sigma2d.plot}}\pysiglinewithargsret{\sphinxbfcode{plot}}{\emph{**kwargs}}{}
Plot the grid half levels using \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.pyplot.html\#module-matplotlib.pyplot}{\sphinxcode{matplotlib.pyplot}}’s utilities.

\begin{sphinxadmonition}{note}{Note:}
For the sake of compliancy with the notation employed by \sphinxhref{http://www.cosmo-model.org}{COSMO},
the vertical geometrical height is denoted by \(z\).
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{**kwargs} \textendash{} Keyword arguments to be forwarded to \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.pyplot.subplots.html\#matplotlib.pyplot.subplots}{\sphinxcode{matplotlib.pyplot.subplots()}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_topography() (grids.sigma.Sigma2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sigma.Sigma2d.update_topography}}\pysiglinewithargsret{\sphinxbfcode{update\_topography}}{\emph{time}}{}
Update the (time-dependent) topography. In turn, the metric terms are re-computed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{float}) \textendash{} Current simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{GalChen2d (class in grids.gal\_chen)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.gal_chen.GalChen2d}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.gal\_chen.}\sphinxbfcode{GalChen2d}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='m'}, \emph{dims\_x='x'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
This class inherits {\hyperref[\detokenize{api:grids.xz_grid.XZGrid}]{\sphinxcrossref{\sphinxcode{XZGrid}}}} to represent a rectangular and regular
two-dimensional grid embedded in a reference system whose coordinates are
\begin{itemize}
\item {} 
the horizontal coordinate \(x\), and

\item {} 
the height-based Gal-Chen terrain-following coordinate \(\mu\).

\end{itemize}

The vertical coordinate \(\mu\) may be formulated to define a hybrid terrain-
following coordinate system with terrain-following coordinate lines between the
surface terrain-height and \(\mu = \mu_F\), where \(\mu\)-coordinate
lines change back to flat horizontal lines.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x}]{\sphinxcrossref{\sphinxstyleliteralstrong{x}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(x\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dx}]{\sphinxcrossref{\sphinxstyleliteralstrong{dx}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(x\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(\mu\)-main levels.

\item {} 
\sphinxstyleliteralstrong{z\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(\mu\)-half levels.

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{dz} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(\mu\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} The interface coordinate \(\mu_F\).

\item {} 
{\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxstyleliteralstrong{topography}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.topography.Topography1d}]{\sphinxcrossref{\sphinxcode{Topography1d}}}} object representing
the topography.

\item {} 
\sphinxstyleliteralstrong{height} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{height\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the half levels.

\item {} 
\sphinxstyleliteralstrong{height\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} geometrical height corresponding to \(\mu = \mu_F\).

\item {} 
\sphinxstyleliteralstrong{reference\_pressure} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{reference\_pressure\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical
height at the half levels.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.gal\_chen.GalChen2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.gal_chen.GalChen2d.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='m'}, \emph{dims\_x='x'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{left}, ~ x_{right})\).

\item {} 
\sphinxstyleliteralstrong{nx} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(x\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_z} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((\mu_{top}, ~ \mu_{surface})\).

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(x\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxtitleref{float}, optional) \textendash{} Interface value \(\mu_F\). If not specified,
it is assumed that \(\mu_F = \mu_T\), with \(\mu_T\) the value of
\(\mu\) at the top of the domain. In other words, a fully terrain-following
coordinate system is supposed.

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}}
for further dmuils.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxtitleref{float}, optional) \textendash{} Simulation time (in seconds) at which the topography
should stop increasing. Default is 0, corresponding to a time-invariant terrain
surface-height. See \sphinxcode{gridis.topography} for further dmuils.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} keyword arguments to be forwarded to the constructor of
{\hyperref[\detokenize{api:grids.topography.Topography1d}]{\sphinxcrossref{\sphinxcode{Topography1d}}}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (grids.gal\_chen.GalChen2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.gal_chen.GalChen2d.plot}}\pysiglinewithargsret{\sphinxbfcode{plot}}{\emph{**kwargs}}{}
Plot the grid half levels using \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.pyplot.html\#module-matplotlib.pyplot}{\sphinxcode{matplotlib.pyplot}}’s utilities.

\begin{sphinxadmonition}{note}{Note:}
For the sake of compliancy with the notation employed by \sphinxhref{http://www.cosmo-model.org}{COSMO},
the vertical geometrical height is denoted by \(z\).
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{**kwargs} \textendash{} Keyword arguments to be forwarded to \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.pyplot.subplots.html\#matplotlib.pyplot.subplots}{\sphinxcode{matplotlib.pyplot.subplots()}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_topography() (grids.gal\_chen.GalChen2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.gal_chen.GalChen2d.update_topography}}\pysiglinewithargsret{\sphinxbfcode{update\_topography}}{\emph{time}}{}
Update the (time-dependent) topography. In turn, the metric terms are re-computed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{float}) \textendash{} Current simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SLEVE2d (class in grids.sleve)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sleve.SLEVE2d}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.sleve.}\sphinxbfcode{SLEVE2d}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='m'}, \emph{dims\_x='x'}, \emph{z\_interface=None}, \emph{N=100}, \emph{s1=8000.0}, \emph{s2=5000.0}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
This class inherits {\hyperref[\detokenize{api:grids.xz_grid.XZGrid}]{\sphinxcrossref{\sphinxcode{XZGrid}}}} to represent a rectangular and regular
two-dimensional grid embedded in a reference system whose coordinates are
\begin{itemize}
\item {} 
the horizontal coordinate \(x\), and

\item {} 
the height-based SLEVE terrain-following coordinate \(\mu\).

\end{itemize}

The vertical coordinate \(\mu\) may be formulated to define a hybrid terrain-
following coordinate system with terrain-following coordinate lines between the
surface terrain-height and \(\mu = \mu_F\), where \(\mu\)-coordinate
lines change back to flat horizontal lines.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x}]{\sphinxcrossref{\sphinxstyleliteralstrong{x}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(x\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dx}]{\sphinxcrossref{\sphinxstyleliteralstrong{dx}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(x\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(\mu\)-main levels.

\item {} 
\sphinxstyleliteralstrong{z\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(\mu\)-half levels.

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{dz} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(\mu\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} The interface coordinate \(\mu_F\).

\item {} 
{\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxstyleliteralstrong{topography}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.topography.Topography1d}]{\sphinxcrossref{\sphinxcode{Topography1d}}}} object representing
the topography.

\item {} 
\sphinxstyleliteralstrong{height} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{height\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the half levels.

\item {} 
\sphinxstyleliteralstrong{height\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} geometrical height corresponding to \(\mu = \mu_F\).

\item {} 
\sphinxstyleliteralstrong{reference\_pressure} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{reference\_pressure\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical
height at the half levels.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.sleve.SLEVE2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sleve.SLEVE2d.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='m'}, \emph{dims\_x='x'}, \emph{z\_interface=None}, \emph{N=100}, \emph{s1=8000.0}, \emph{s2=5000.0}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{left}, ~ x_{right})\).

\item {} 
\sphinxstyleliteralstrong{nx} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(x\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_z} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((\mu_{top}, ~ \mu_{surface})\).

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(x\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxtitleref{float}, optional) \textendash{} Interface value \(\mu_F\). If not specified,
it is assumed that \(\mu_F = \mu_T\), with \(\mu_T\) the value of
\(\mu\) at the top of the domain. In other words, a fully terrain-following
coordinate system is supposed.

\item {} 
\sphinxstyleliteralstrong{N} (\sphinxtitleref{int}, optional) \textendash{} Number of filter iterations performed to determine the
large-scale component of the surface terrain-height. Defaults to 100.

\item {} 
\sphinxstyleliteralstrong{s1} (\sphinxtitleref{float}, optional) \textendash{} Large-scale decay constant. Defaults to \(8000 ~ m\).

\item {} 
\sphinxstyleliteralstrong{s2} (\sphinxtitleref{float}, optional) \textendash{} Small-scale decay constant. Defaults to \(5000 ~ m\).

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}}
for further dmuils.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxtitleref{float}, optional) \textendash{} Simulation time (in seconds) at which the topography
should stop increasing. Default is 0, corresponding to a time-invariant terrain
surface-height. See \sphinxcode{gridis.topography} for further dmuils.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} keyword arguments to be forwarded to the constructor of
{\hyperref[\detokenize{api:grids.topography.Topography1d}]{\sphinxcrossref{\sphinxcode{Topography1d}}}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (grids.sleve.SLEVE2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sleve.SLEVE2d.plot}}\pysiglinewithargsret{\sphinxbfcode{plot}}{\emph{**kwargs}}{}
Plot the grid half levels using \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.pyplot.html\#module-matplotlib.pyplot}{\sphinxcode{matplotlib.pyplot}}’s utilities.

\begin{sphinxadmonition}{note}{Note:}
For the sake of compliancy with the notation employed by \sphinxhref{http://www.cosmo-model.org}{COSMO},
the vertical geometrical height is denoted by \(z\).
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{**kwargs} \textendash{} Keyword arguments to be forwarded to \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.pyplot.subplots.html\#matplotlib.pyplot.subplots}{\sphinxcode{matplotlib.pyplot.subplots()}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_topography() (grids.sleve.SLEVE2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sleve.SLEVE2d.update_topography}}\pysiglinewithargsret{\sphinxbfcode{update\_topography}}{\emph{time}}{}
Update the (time-dependent) topography. In turn, the metric terms are re-computed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{float}) \textendash{} Current simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Three-dimensional grids}
\label{\detokenize{api:three-dimensional-grids}}\index{XYZGrid (class in grids.xyz\_grid)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.xyz\_grid.}\sphinxbfcode{XYZGrid}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}, \emph{units\_z='m'}, \emph{dims\_z='z'}, \emph{z\_interface=None}, \emph{topo\_type='flat\_terrain'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Rectangular and regular three-dimensional grid embedded in a reference system whose
coordinates are
\begin{itemize}
\item {} 
the first horizontal coordinate \(x\),

\item {} 
the second horizontal coordinate \(y\), and

\item {} 
the vertical (terrain-following) coordinate \(z\).

\end{itemize}

The vertical coordinate \(z\) may be formulated to define a hybrid terrain-
following coordinate system with terrain-following coordinate lines between the
surface terrain-height and \(z = z_F\), where \(z\)-coordinate lines change
back to flat horizontal lines. However, no assumption is made on the actual nature
of \(z\) which may be either pressure-based or height-based.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xy\_grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} The \(xy\)-grid. This is a {\hyperref[\detokenize{api:grids.xy_grid.XYGrid}]{\sphinxcrossref{\sphinxcode{XYGrid}}}}.

\item {} 
\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(z\)-main levels.

\item {} 
\sphinxstyleliteralstrong{z\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(z\)-half levels.

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{dz} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(z\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} The interface coordinate \(z_F\).

\item {} 
\sphinxstyleliteralstrong{\_topography} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.topography.Topography2d}]{\sphinxcrossref{\sphinxcode{Topography2d}}}} object representing
the topography.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
For the sake of compliancy with the \sphinxhref{http://cosmo-model.org}{COSMO model},
the vertical grid points are ordered from the top of the domain to the surface.
\end{sphinxadmonition}
\index{\_\_init\_\_() (grids.xyz\_grid.XYZGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}, \emph{units\_z='m'}, \emph{dims\_z='z'}, \emph{z\_interface=None}, \emph{topo\_type='flat\_terrain'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{start}, ~ x_{stop})\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(x\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_y} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((y_{start}, ~ y_{stop})\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.ny}]{\sphinxcrossref{\sphinxstyleliteralstrong{ny}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(y\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_z} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((z_{top}, ~ z_{surface})\).

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(x\)-coordinate. Must be compliant
with the \sphinxhref{cfconventions.org}{CF Conventions}.


\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{units\_y} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(y\)-coordinate. Must be compliant
with the \sphinxhref{cfconventions.org}{CF Conventions}.


\item {} 
\sphinxstyleliteralstrong{dims\_y} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(y\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{units\_z} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(z\)-coordinate. Must be compliant
with the \sphinxhref{cfconventions.org}{CF Conventions}.


\item {} 
\sphinxstyleliteralstrong{dims\_z} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(z\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxtitleref{float}, optional) \textendash{} Interface value \(z_F\). If not specified,
it is assumed that \(z_F = z_T\), with \(z_T\) the value of \(z\)
at the top of the domain. In other words, a fully terrain-following coordinate
system is supposed.

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}}
for further details.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxtitleref{float}, optional) \textendash{} Simulation time (in seconds) at which the topography
should stop increasing. Default is 0, corresponding to a time-invariant terrain
surface-height. See \sphinxcode{gridis.topography} for further details.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} keyword arguments to be forwarded to the constructor of
{\hyperref[\detokenize{api:grids.topography.Topography2d}]{\sphinxcrossref{\sphinxcode{Topography2d}}}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{dx (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.dx}}\pysigline{\sphinxbfcode{dx}}
Get the \(x\)-spacing.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The \(x\)-spacing.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{dy (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.dy}}\pysigline{\sphinxbfcode{dy}}
Get the \(y\)-spacing.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The \(y\)-spacing.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{nx (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.nx}}\pysigline{\sphinxbfcode{nx}}
Get the number of grid points in the \(x\)-direction.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Number of grid points in the \(x\)-direction.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{ny (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.ny}}\pysigline{\sphinxbfcode{ny}}
Get the number of grid points in the \(y\)-direction.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Number of grid points in the \(y\)-direction.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{topography\_height (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.topography_height}}\pysigline{\sphinxbfcode{topography\_height}}
Get the topography (i.e., terrain-surface) height.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Two-dimensional \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} carrying the topography height.

\item[{Return type}] \leavevmode
array\_like

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_topography() (grids.xyz\_grid.XYZGrid method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.update_topography}}\pysiglinewithargsret{\sphinxbfcode{update\_topography}}{\emph{time}}{}
Update the (time-dependent) topography.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxcode{datetime.timedelta} object, representing the elapsed simulation time.

\end{description}\end{quote}

\end{fulllineitems}

\index{x (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.x}}\pysigline{\sphinxbfcode{x}}
Get the \(x\)-axis.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
{\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(x\)-axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{x\_half\_levels (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.x_half_levels}}\pysigline{\sphinxbfcode{x\_half\_levels}}
Get the \sphinxcode{Axis} object storing the \(x\) half levels.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
{\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(x\) half levels.

\end{description}\end{quote}

\end{fulllineitems}

\index{y (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.y}}\pysigline{\sphinxbfcode{y}}
Get the \(y\)-axis.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
{\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(y\)-axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{y\_half\_levels (grids.xyz\_grid.XYZGrid attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.xyz_grid.XYZGrid.y_half_levels}}\pysigline{\sphinxbfcode{y\_half\_levels}}
Get the \sphinxcode{Axis} object storing the \(y\) half levels.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
{\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(y\) half levels.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Sigma3d (class in grids.sigma)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sigma.Sigma3d}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.sigma.}\sphinxbfcode{Sigma3d}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
This class inherits {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} to represent a rectangular and regular
computational grid embedded in a three-dimensional terrain-following reference system, whose
coordinates are:
\begin{itemize}
\item {} 
first horizontal coordinate \(x\), e.g., the longitude;

\item {} 
second horizontal coordinate \(y\), e.g., the latitude;

\item {} 
the pressure-based terrain-following coordinate \(\sigma = p / p_{SL}\),                  where \(p\) is the pressure and \(p_{SL}\) the pressure at the                  sea level.

\end{itemize}

The vertical coordinate \(\sigma\) may be formulated to define a hybrid terrain-
following coordinate system with terrain-following coordinate lines between the
surface terrain-height and \(\sigma = \sigma_F\), where \(\sigma\)-coordinate
lines change back to flat horizontal lines.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x}]{\sphinxcrossref{\sphinxstyleliteralstrong{x}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(x\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dx}]{\sphinxcrossref{\sphinxstyleliteralstrong{dx}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(x\)-spacing.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.y}]{\sphinxcrossref{\sphinxstyleliteralstrong{y}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(y\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.ny}]{\sphinxcrossref{\sphinxstyleliteralstrong{ny}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(y\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dy}]{\sphinxcrossref{\sphinxstyleliteralstrong{dy}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(y\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(\sigma\)-main levels.

\item {} 
\sphinxstyleliteralstrong{z\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(\sigma\)-half levels.

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{dz} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(\sigma\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} The interface coordinate \(\sigma_F\).

\item {} 
{\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxstyleliteralstrong{topography}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.topography.Topography2d}]{\sphinxcrossref{\sphinxcode{Topography2d}}}} object representing
the topography.

\item {} 
\sphinxstyleliteralstrong{height} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{height\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the half levels.

\item {} 
\sphinxstyleliteralstrong{height\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} geometrical height corresponding to \(\sigma = \sigma_F\).

\item {} 
\sphinxstyleliteralstrong{reference\_pressure} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{reference\_pressure\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical
height at the half levels.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.sigma.Sigma3d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sigma.Sigma3d.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{left}, ~ x_{right})\).

\item {} 
\sphinxstyleliteralstrong{nx} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(x\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_y} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((y_{left}, ~ y_{right})\).

\item {} 
\sphinxstyleliteralstrong{ny} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(y\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_z} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((\sigma_{top}, ~ \sigma_{surface})\).

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(x\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{units\_y} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(y\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_y} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(y\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxtitleref{float}, optional) \textendash{} Interface value \(\sigma_F\). If not specified,
it is assumed that \(\sigma_F = \sigma_T\), with \(\sigma_T\) the value of
\(\sigma\) at the top of the domain. In other words, a fully terrain-following
coordinate system is supposed.

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}}
for further details.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxtitleref{float}, optional) \textendash{} Simulation time (in seconds) at which the topography
should stop increasing. Default is 0, corresponding to a time-invariant terrain
surface-height. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}} for further details.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} keyword arguments to be forwarded to the constructor of
{\hyperref[\detokenize{api:grids.topography.Topography2d}]{\sphinxcrossref{\sphinxcode{Topography2d}}}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_topography() (grids.sigma.Sigma3d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sigma.Sigma3d.update_topography}}\pysiglinewithargsret{\sphinxbfcode{update\_topography}}{\emph{time}}{}
Update the (time-dependent) topography. In turn, the metric terms are re-computed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{float}) \textendash{} Current simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{GalChen3d (class in grids.gal\_chen)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.gal_chen.GalChen3d}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.gal\_chen.}\sphinxbfcode{GalChen3d}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
This class inherits {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} to represent a rectangular and regular
computational grid embedded in a three-dimensional terrain-following reference system, whose
coordinates are:
\begin{itemize}
\item {} 
first horizontal coordinate \(x\), e.g., the longitude;

\item {} 
second horizontal coordinate \(y\), e.g., the latitude;

\item {} 
the Gal-Chen terrain-following coordinate \(\mu\).

\end{itemize}

The vertical coordinate \(\mu\) may be formulated to define a hybrid terrain-
following coordinate system with terrain-following coordinate lines between the
surface terrain-height and \(\mu = \mu_F\), where \(\mu\)-coordinate
lines change back to flat horizontal lines.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x}]{\sphinxcrossref{\sphinxstyleliteralstrong{x}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(x\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dx}]{\sphinxcrossref{\sphinxstyleliteralstrong{dx}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(x\)-spacing.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.y}]{\sphinxcrossref{\sphinxstyleliteralstrong{y}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(y\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.ny}]{\sphinxcrossref{\sphinxstyleliteralstrong{ny}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(y\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dy}]{\sphinxcrossref{\sphinxstyleliteralstrong{dy}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(y\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(z\)-main levels.

\item {} 
\sphinxstyleliteralstrong{z\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(z\)-half levels.

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{dz} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(z\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} The interface coordinate \(z_F\).

\item {} 
{\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxstyleliteralstrong{topography}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.topography.Topography2d}]{\sphinxcrossref{\sphinxcode{Topography2d}}}} object representing
the topography.

\item {} 
\sphinxstyleliteralstrong{height} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{height\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the half levels.

\item {} 
\sphinxstyleliteralstrong{height\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} geometrical height corresponding to \(\mu = \mu_F\).

\item {} 
\sphinxstyleliteralstrong{reference\_pressure} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{reference\_pressure\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical
height at the half levels.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.gal\_chen.GalChen3d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.gal_chen.GalChen3d.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}, \emph{z\_interface=None}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{left}, ~ x_{right})\).

\item {} 
\sphinxstyleliteralstrong{nx} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(x\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_y} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((y_{left}, ~ y_{right})\).

\item {} 
\sphinxstyleliteralstrong{ny} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(y\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_z} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((\mu_{top}, ~ \mu_{surface})\).

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(x\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{units\_y} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(y\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_y} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(y\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxtitleref{float}, optional) \textendash{} Interface value \(zmu_F = \mu_F\). If not
specified, it is assumed that \(\mu_F = \mu_T\), with \(\mu_T\) the
value of \(\mu\) at the top of the domain. In other words, a fully terrain-following
coordinate nsystem is supposed.

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}}
for further dmuils.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxtitleref{float}, optional) \textendash{} Simulation time (in seconds) at which the topography
should stop increasing. Default is 0, corresponding to a time-invariant terrain
surface-height. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}} for further dmuils.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} keyword arguments to be forwarded to the constructor of
{\hyperref[\detokenize{api:grids.topography.Topography2d}]{\sphinxcrossref{\sphinxcode{Topography2d}}}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_topography() (grids.gal\_chen.GalChen3d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.gal_chen.GalChen3d.update_topography}}\pysiglinewithargsret{\sphinxbfcode{update\_topography}}{\emph{time}}{}
Update the (time-dependent) topography. In turn, the metric terms are re-computed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{float}) \textendash{} Current simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SLEVE3d (class in grids.sleve)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sleve.SLEVE3d}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.sleve.}\sphinxbfcode{SLEVE3d}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}, \emph{z\_interface=None}, \emph{N=100}, \emph{s1=8000.0}, \emph{s2=5000.0}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
This class inherits {\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid}]{\sphinxcrossref{\sphinxcode{XYZGrid}}}} to represent a rectangular and regular
computational grid embedded in a three-dimensional terrain-following reference system, whose
coordinates are:
\begin{itemize}
\item {} 
first horizontal coordinate \(x\), e.g., the longitude;

\item {} 
second horizontal coordinate \(y\), e.g., the latitude;

\item {} 
the SLEVE terrain-following coordinate \(\mu\).

\end{itemize}

The vertical coordinate \(\mu\) may be formulated to define a hybrid terrain-
following coordinate system with terrain-following coordinate lines between the
surface terrain-height and \(\mu = \mu_F\), where \(\mu\)-coordinate
lines change back to flat horizontal lines.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.x}]{\sphinxcrossref{\sphinxstyleliteralstrong{x}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(x\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.nx}]{\sphinxcrossref{\sphinxstyleliteralstrong{nx}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(x\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dx}]{\sphinxcrossref{\sphinxstyleliteralstrong{dx}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(x\)-spacing.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.y}]{\sphinxcrossref{\sphinxstyleliteralstrong{y}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the \(y\)-axis.

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.ny}]{\sphinxcrossref{\sphinxstyleliteralstrong{ny}}}} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points along \(y\).

\item {} 
{\hyperref[\detokenize{api:grids.xyz_grid.XYZGrid.dy}]{\sphinxcrossref{\sphinxstyleliteralstrong{dy}}}} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(y\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(z\)-main levels.

\item {} 
\sphinxstyleliteralstrong{z\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object storing the \(z\)-half levels.

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{dz} (\sphinxstyleliteralemphasis{float}) \textendash{} The \(z\)-spacing.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} The interface coordinate \(z_F\).

\item {} 
{\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxstyleliteralstrong{topography}}}} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.topography.Topography2d}]{\sphinxcrossref{\sphinxcode{Topography2d}}}} object representing
the topography.

\item {} 
\sphinxstyleliteralstrong{height} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{height\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the half levels.

\item {} 
\sphinxstyleliteralstrong{height\_interface} (\sphinxstyleliteralemphasis{float}) \textendash{} geometrical height corresponding to \(\mu = \mu_F\).

\item {} 
\sphinxstyleliteralstrong{reference\_pressure} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical height at
the main levels.

\item {} 
\sphinxstyleliteralstrong{reference\_pressure\_half\_levels} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the geometrical
height at the half levels.

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.sleve.SLEVE3d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sleve.SLEVE3d.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{domain\_x}, \emph{nx}, \emph{domain\_y}, \emph{ny}, \emph{domain\_z}, \emph{nz}, \emph{units\_x='degrees\_east'}, \emph{dims\_x='longitude'}, \emph{units\_y='degrees\_north'}, \emph{dims\_y='latitude'}, \emph{z\_interface=None}, \emph{N=100}, \emph{s1=8000.0}, \emph{s2=5000.0}, \emph{topo\_type='terrain\_flat'}, \emph{topo\_time=0.0}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{domain\_x} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((x_{left}, ~ x_{right})\).

\item {} 
\sphinxstyleliteralstrong{nx} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(x\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_y} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((y_{left}, ~ y_{right})\).

\item {} 
\sphinxstyleliteralstrong{ny} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of grid points in the \(y\)-direction.

\item {} 
\sphinxstyleliteralstrong{domain\_z} (\sphinxstyleliteralemphasis{tuple}) \textendash{} Tuple in the form \((\mu_{top}, ~ \mu_{surface})\).

\item {} 
\sphinxstyleliteralstrong{nz} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of vertical main levels.

\item {} 
\sphinxstyleliteralstrong{units\_x} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(x\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_x} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(x\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{units\_y} (\sphinxtitleref{str}, optional) \textendash{} 
Units for the \(y\)-coordinate. Must be compliant
with the \sphinxhref{http://cfconventions.org}{CF Conventions} (see also
{\hyperref[\detokenize{api:grids.axis.Axis.__init__}]{\sphinxcrossref{\sphinxcode{grids.axis.Axis.\_\_init\_\_()}}}}).


\item {} 
\sphinxstyleliteralstrong{dims\_y} (\sphinxtitleref{str}, optional) \textendash{} Label for the \(y\)-coordinate.

\item {} 
\sphinxstyleliteralstrong{z\_interface} (\sphinxtitleref{float}, optional) \textendash{} Interface value \(zmu_F = \mu_F\). If not
specified, it is assumed that \(\mu_F = \mu_T\), with \(\mu_T\) the
value of \(\mu\) at the top of the domain. In other words, a fully terrain-following
coordinate nsystem is supposed.

\item {} 
\sphinxstyleliteralstrong{N} (\sphinxtitleref{int}, optional) \textendash{} Number of filter iterations performed to determine the
large-scale component of the surface terrain-height. Defaults to 100.

\item {} 
\sphinxstyleliteralstrong{s1} (\sphinxtitleref{float}, optional) \textendash{} Large-scale decay constant. Defaults to \(8000 ~ m\).

\item {} 
\sphinxstyleliteralstrong{s2} (\sphinxtitleref{float}, optional) \textendash{} Small-scale decay constant. Defaults to \(5000 ~ m\).

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}}
for further dmuils.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxtitleref{float}, optional) \textendash{} Simulation time (in seconds) at which the topography
should stop increasing. Default is 0, corresponding to a time-invariant terrain
surface-height. See {\hyperref[\detokenize{api:module-grids.topography}]{\sphinxcrossref{\sphinxcode{grids.topography}}}} for further dmuils.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} keyword arguments to be forwarded to the constructor of
{\hyperref[\detokenize{api:grids.topography.Topography2d}]{\sphinxcrossref{\sphinxcode{Topography2d}}}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_topography() (grids.sleve.SLEVE3d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.sleve.SLEVE3d.update_topography}}\pysiglinewithargsret{\sphinxbfcode{update\_topography}}{\emph{time}}{}
Update the (time-dependent) topography. In turn, the metric terms are re-computed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{float}) \textendash{} Current simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Namelist}
\label{\detokenize{api:namelist}}\label{\detokenize{api:module-namelist}}\index{namelist (module)}
Configuration and global variables used throughout the package.
\begin{description}
\item[{Physical constants:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{namelist.p\_ref}: Reference pressure ({[}\(Pa\){]}).

\item {} 
\sphinxcode{namelist.p\_sl}: Reference pressure at sea level ({[}\(Pa\){]}).

\item {} 
\sphinxcode{namelist.T\_sl}: Reference temperature at sea level ({[}\(K\){]}).

\item {} 
\sphinxcode{namelist.beta}: Rate of increase in reference temperature with the logarithm           of reference pressure ({[}\(K ~ Pa^{-1}\){]}).

\item {} 
\sphinxcode{namelist.Rd}: Gas constant for dry airi ({[}\(J ~ K^{-1} ~ Kg^{-1}\){]}).

\item {} 
\sphinxcode{namelist.cp}: Specific heat of dry air at constant pressure ({[}\(J ~ K^{-1} ~ Kg^{-1}\){]}).

\item {} 
\sphinxcode{namelist.g}: Mean gravitational acceleration ({[}\(m ~ s^{-2}\){]}).

\end{itemize}

\item[{Grid settings:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{namelist.domain\_x}: Tuple storing the boundaries of the domain in the \(x\)-direction              in the form (\(x_{west}\), \(x_{east}\)).

\item {} 
\sphinxcode{namelist.nx}: Number of grid points in the \(x\)-direction.

\item {} 
\sphinxcode{namelist.domain\_y}: Tuple storing the boundaries of the domain in the \(y\)-direction              in the form (\(y_{south}\), \(y_{north}\)).

\item {} 
\sphinxcode{namelist.ny}: Number of grid points in the \(y\)-direction.

\item {} 
\sphinxcode{namelist.domain\_z}: Tuple storing the boundaries of the domain in the \(z\)-direction              in the form (\(z_{top}\), \(z_{bottom}\)).

\item {} 
\sphinxcode{namelist.nz}: Number of grid points in the \(z\)-direction.

\item {} 
\sphinxcode{namelist.z\_interface}: For a hybrid coordinate system, interface level at which terrain-following              \(z\)-coordinate lines get back to horizontal lines.

\item {} 
\sphinxcode{namelist.topo\_type}: Topography type. Available options are:
\begin{itemize}
\item {} 
‘flat\_terrain’;

\item {} 
‘gaussian’;

\item {} 
‘schaer’;

\item {} 
‘user\_defined’.

\end{itemize}

\item {} 
\sphinxcode{namelist.topo\_time}: \sphinxcode{datetime.timedelta} object representing the elapsed simulation time                               after which the topography should stop increasing.

\item {} 
\sphinxcode{namelist.topo\_max\_height}: When \sphinxcode{topo\_type} is ‘gaussian’, maximum mountain height ({[}\(m\){]}).

\item {} 
\sphinxcode{namelist.topo\_width\_x}: When \sphinxcode{topo\_type} is ‘gaussian’, mountain half-width in \(x\)-direction             ({[}\(m\){]}).

\item {} 
\sphinxcode{namelist.topo\_width\_y}: When \sphinxcode{topo\_type} is ‘gaussian’, mountain half-width in \(y\)-direction             ({[}\(m\){]}).

\item {} 
\sphinxcode{namelist.topo\_str}: When \sphinxcode{topo\_type} is ‘user\_defined’, terrain profile expression in the independent          variables \(x\) and \(y\). Must be fully C++-compliant.

\end{itemize}

\item[{Model settings:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{namelist.model\_name}: Name of the model to implement. Available options are:
\begin{itemize}
\item {} 
‘isentropic’, for the isentropic model.

\end{itemize}

\item {} 
\sphinxcode{namelist.imoist}: \sphinxcode{True} if water constituents should be taken into account, \sphinxcode{False} otherwise.

\item {} 
\sphinxcode{namelist.horizontal\_boundary\_type}: Horizontal boundary conditions. Available options are:
\begin{itemize}
\item {} 
‘periodic’, for periodic boundary conditions;

\item {} 
‘relaxed’, for relaxed boundary conditions.

\end{itemize}

\end{itemize}

\item[{Numerical settings:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{namelist.scheme}: Numerical scheme to implement. For the isentropic model, available options are:
\begin{itemize}
\item {} 
‘upwind’, for the first-order upwind scheme;

\item {} 
‘leapfrog’, for the second-order leapfrog scheme;

\item {} 
‘maccormack’, for the second-order maccormack scheme.

\end{itemize}

\item {} 
\sphinxcode{namelist.idamp}: \sphinxcode{True} if (explicit) vertical damping should be applied, \sphinxcode{False} otherwise.               Note that when vertical damping is switched off, the numerical diffusion is monotonically increased towards             the top of the model, so to act as a diffusive wave absorber.

\item {} 
\sphinxcode{namelist.damp\_type}: Type of vertical damping to apply. Available options are:
\begin{itemize}
\item {} 
‘rayleigh’, for Rayleigh vertical damping.

\end{itemize}

\item {} 
\sphinxcode{namelist.damp\_depth}: Number of levels (either main levels or half levels) in the absorbing region.

\item {} 
\sphinxcode{namelist.damp\_max}: Maximum value which should be assumed by the damping coefficient.

\item {} 
\sphinxcode{namelist.idiff}: \sphinxcode{True} to add numerical horizontal diffusion, \sphinxcode{False} otherwise.

\item {} 
\sphinxcode{namelist.diff\_coeff}: The diffusion coefficient, i.e., the diffusivity.

\item {} 
\sphinxcode{namelist.diff\_coeff\_moist}: The diffusion coefficient, i.e., the diffusivity, for the moisture components.

\item {} 
\sphinxcode{namelist.diff\_max}: Maximum value which should be assumed by the diffusivity when diffusive vertical damping is applied.

\end{itemize}

\item[{Simulation settings:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{namelist.dt}: \sphinxcode{datetime.timedelta} object representing the timestep.

\item {} 
\sphinxcode{namelist.initial\_time}: \sphinxcode{datetime.datetime} representing the initial simulation time.

\item {} 
\sphinxcode{namelist.simulation\_time}: \sphinxcode{datetime.timedelta} object representing the simulation time.

\item {} 
\sphinxcode{namelist.x\_velocity\_initial}: The initial, uniform \(x\)-velocity ({[}\(m s^{-1}\){]}).

\item {} 
\sphinxcode{namelist.y\_velocity\_initial}: The initial, uniform \(y\)-velocity ({[}\(m s^{-1}\){]}).

\item {} 
\sphinxcode{namelist.brunt\_vaisala\_initial}: The initial, uniform Brunt-Vaisala frequency.

\item {} 
\sphinxcode{namelist.backend}: GT4Py’s backend to use. Available options are:
\begin{itemize}
\item {} 
\sphinxcode{gridtools.mode.NUMPY}: Numpy (i.e., vectorized) backend.

\end{itemize}

\item {} 
\sphinxcode{namelist.save\_freq}: Save state every \sphinxcode{freq} iterations.

\item {} 
\sphinxcode{namelist.save\_dest}: Path to the location where results should be saved.

\item {} 
\sphinxcode{namelist.tol}: Tolerance used to compare floats (see {\hyperref[\detokenize{api:module-utils}]{\sphinxcrossref{\sphinxcode{utils}}}}).

\item {} 
\sphinxcode{namelist.datatype}: Datatype for \sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}}. Either \sphinxcode{np.float32}             or \sphinxcode{np.float64}.

\end{itemize}

\end{description}


\section{Storages}
\label{\detokenize{api:storages}}\index{GridData (class in storages.grid\_data)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.grid_data.GridData}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{storages.grid\_data.}\sphinxbfcode{GridData}}{\emph{time}, \emph{grid}, \emph{**kwargs}}{}
Class storing and handling time-dependent variables defined on a grid. Ideally, this class should be used to
represent the state, or a sequence of states, of a \sphinxstyleemphasis{generic} climate or meteorological model. The model variables,
in the shape of \sphinxcode{numpy.ndarray{}`s, are passed to the constructor as keyword arguments. After conversion to
:class:{}`xarray.DataArray{}`s, the variables are packed in a dictionary whose keys are the input keywords. The
class attribute :data:{}`units} lists, for any admissible keyword, the units in which the associated field should
be expressed. Any variable can be accessed in read-only mode via the accessor operator by specifying the
corresponding keyword. Other methods are provided to update the state, or to create a sequence of states
(useful for animation purposes).
This class is designed be as general as possible. Hence, it is not endowed with any method whose
implementation depends on the variables actually stored by the class. This kind of methods will be
provided by the derived classes, each one representing the state of a \sphinxstyleemphasis{specific} model.
\index{\_\_getitem\_\_() (storages.grid\_data.GridData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.grid_data.GridData.__getitem__}}\pysiglinewithargsret{\sphinxbfcode{\_\_getitem\_\_}}{\emph{key}}{}
Access a gridded variable in read-only mode.

\end{fulllineitems}

\index{\_\_init\_\_() (storages.grid\_data.GridData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.grid_data.GridData.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{time}, \emph{grid}, \emph{**kwargs}}{}
Constructor.

\end{fulllineitems}

\index{append() (storages.grid\_data.GridData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.grid_data.GridData.append}}\pysiglinewithargsret{\sphinxbfcode{append}}{\emph{state\_new}}{}
Append a new state to the sequence of states.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{state\_new} (\sphinxstyleliteralemphasis{obj}) \textendash{} The new {\hyperref[\detokenize{api:storages.grid_data.GridData}]{\sphinxcrossref{\sphinxcode{GridData}}}} to append.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_max() (storages.grid\_data.GridData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.grid_data.GridData.get_max}}\pysiglinewithargsret{\sphinxbfcode{get\_max}}{\emph{field}}{}
Get maximum value of a field.

\end{fulllineitems}

\index{get\_min() (storages.grid\_data.GridData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.grid_data.GridData.get_min}}\pysiglinewithargsret{\sphinxbfcode{get\_min}}{\emph{field}}{}
Get minimum value of a field.

\end{fulllineitems}

\index{time (storages.grid\_data.GridData attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.grid_data.GridData.time}}\pysigline{\sphinxbfcode{time}}
Return the time at which the state corresponds.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A \sphinxcode{datetime.datetime} object representing the current time.

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (storages.grid\_data.GridData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.grid_data.GridData.update}}\pysiglinewithargsret{\sphinxbfcode{update}}{\emph{state\_new}}{}
Update (some of) the gridded variables.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{state\_new} (\sphinxstyleliteralemphasis{obj}) \textendash{} A {\hyperref[\detokenize{api:storages.grid_data.GridData}]{\sphinxcrossref{\sphinxcode{GridData}}}} carrying the updated model variables.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{state\_new} is not required to carry \sphinxstyleemphasis{all} the model variables.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{IsentropicState (class in storages.isentropic\_state)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.isentropic_state.IsentropicState}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{storages.isentropic\_state.}\sphinxbfcode{IsentropicState}}{\emph{time}, \emph{grid}, \emph{isentropic\_density}, \emph{x\_velocity}, \emph{y\_velocity}, \emph{pressure}, \emph{exner\_function}, \emph{montgomery\_potential}, \emph{height}, \emph{water\_vapour=None}, \emph{cloud\_water=None}, \emph{precipitation\_water=None}}{}
This class inherits {\hyperref[\detokenize{api:storages.grid_data.GridData}]{\sphinxcrossref{\sphinxcode{GridData}}}} to represent the state of the three-dimensional
(moist) isentropic model.
\index{\_\_init\_\_() (storages.isentropic\_state.IsentropicState method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.isentropic_state.IsentropicState.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{time}, \emph{grid}, \emph{isentropic\_density}, \emph{x\_velocity}, \emph{y\_velocity}, \emph{pressure}, \emph{exner\_function}, \emph{montgomery\_potential}, \emph{height}, \emph{water\_vapour=None}, \emph{cloud\_water=None}, \emph{precipitation\_water=None}}{}
Constructor.

\end{fulllineitems}

\index{get\_cfl() (storages.isentropic\_state.IsentropicState method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.isentropic_state.IsentropicState.get_cfl}}\pysiglinewithargsret{\sphinxbfcode{get\_cfl}}{\emph{dt}}{}
Compute the CFL number. If this is greater than one, i.e., if the CFL condition is violated,
the method throws a warning.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxcode{datetime.timedelta} object representing the time step.

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_xy() (storages.isentropic\_state.IsentropicState method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.isentropic_state.IsentropicState.plot_xy}}\pysiglinewithargsret{\sphinxbfcode{plot\_xy}}{\emph{field\_to\_plot}, \emph{z\_level}, \emph{time\_level}, \emph{**kwargs}}{}
Plot a field at the level :math:{}`       heta = ar\{     heta\}{}`.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{field\_to\_plot} (\sphinxstyleliteralemphasis{str}) \textendash{} String specifying the field to plot. This may be
either a model variable or a diagnosed field, as:
* ‘horizontal\_velocity’, i.e., the horizontal velocity field.

\item {} 
\sphinxstyleliteralstrong{z\_level} (\sphinxstyleliteralemphasis{int}) \textendash{} Index corresponding to the :math:{}`       heta{}`-level identifying
the \((x,y)\)-cross-section to plot.

\item {} 
\sphinxstyleliteralstrong{time\_level} (\sphinxstyleliteralemphasis{int}) \textendash{} The index corresponding to the time level to plot.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} Keyword arguments defining various plotting settings.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_xz() (storages.isentropic\_state.IsentropicState method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:storages.isentropic_state.IsentropicState.plot_xz}}\pysiglinewithargsret{\sphinxbfcode{plot\_xz}}{\emph{field\_to\_plot}, \emph{y\_level}, \emph{time\_level}, \emph{**kwargs}}{}
Plot a field in the plane \(y = ar{y}\).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{field\_to\_plot} (\sphinxstyleliteralemphasis{str}) \textendash{} String specifying the model variable to plot.

\item {} 
\sphinxstyleliteralstrong{y\_level} (\sphinxstyleliteralemphasis{int}) \textendash{} Index corresponding to the \(y\)-level identifying
the \((x,z)\)-cross-section to plot.

\item {} 
\sphinxstyleliteralstrong{time\_level} (\sphinxstyleliteralemphasis{int}) \textendash{} The index corresponding to the time level to plot.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} Keyword arguments defining various plotting settings.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Topography}
\label{\detokenize{api:topography}}\label{\detokenize{api:module-grids.topography}}\index{grids.topography (module)}
Classes representing one- and two-dimensional topographies, possibly time-dependent.
Indeed, although clearly not physical, a terrain surface (slowly) growing in the early stages
of a simulation may help to retrieve numerical stability, as it prevents steep gradients
to raise up in the first few iterations.

Letting \(h_s = h_s(x)\) be a one-dimensional topography, with \(x \in [a,b]\),
the user may choose among:
\begin{itemize}
\item {} 
a flat terrain, i.e., \(h_s(x) \equiv 0\);

\item {} 
a Gaussian-shaped mountain, i.e.,
\begin{quote}
\begin{equation*}
\begin{split}h_s(x) = h_{max} \exp{\left[ - \left( \frac{x - c}{\sigma_x} \right)^2 \right]},\end{split}
\end{equation*}\end{quote}

where \(c = 0.5 (a + b)\).

\end{itemize}

For the two-dimensional case, letting \(h_s = h_s(x,y)\) be the topography, with
\(x \in [a_x,b_x]\) and \(y \in [a_y,b_y]\), the following profiles are provided:
\begin{itemize}
\item {} 
flat terrain, i.e., \(h_s(x,y) \equiv 0\);

\item {} 
Gaussian shaped-mountain, i.e.
\begin{quote}
\begin{equation*}
\begin{split}h_s(x,y) = h_{max} \exp{\left[ - \left( \frac{x - c_x}{\sigma_x} \right)^2 - \left( \frac{y - c_y}{\sigma_y} \right)^2 \right]} ,\end{split}
\end{equation*}\end{quote}

where \(c_x = 0.5 (a_x + b_x)\) and \(c_y = 0.5 (a_y + b_y)\);

\item {} 
modified Gaussian-shaped mountain proposed by Schaer and Durran (1997),
\begin{quote}
\begin{equation*}
\begin{split}h_s(x,y) = \frac{h_{max}}{\left[ 1 + \left( \frac{x - c_x}{\sigma_x} \right)^2 + \left( \frac{y - c_y}{\sigma_y} \right)^2 \right]^{3/2}},\end{split}
\end{equation*}\end{quote}

where, as above, \(c_x = 0.5 (a_x + b_x)\) and \(c_y = 0.5 (a_y + b_y)\).

\end{itemize}

Yet, user-defined profiles are supported as well, provided that they admit an analytical expression.
This is passed to the class as a string, which is then parsed in C++ via \sphinxhref{http://cython.org}{Cython}
(see \sphinxcode{parser\_1d} and \sphinxcode{parser\_2d}). Hence, the string itself must be
fully C++-compliant.
\paragraph{References}

Schaer, C., and Durran, D. R. (1997). \sphinxstyleemphasis{Vortex formation and vortex shedding in continuosly stratified flows     past isolated topography}. Journal of Atmospheric Sciences, 54:534-554.
\index{Topography1d (class in grids.topography)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.topography.Topography1d}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.topography.}\sphinxbfcode{Topography1d}}{\emph{x}, \emph{topo\_type='flat\_terrain'}, \emph{topo\_time=datetime.timedelta(0)}, \emph{**kwargs}}{}
One-dimensional topography.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{topo} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} A \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the topography (in meters).

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxstyleliteralemphasis{str}) \textendash{} Topography type. Either ‘flat\_terrain’, ‘gaussian’ or ‘user\_defined’.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxcode{datetime.timedelta} object representing the elapsed simulation time
after which the topography should stop increasing.

\item {} 
\sphinxstyleliteralstrong{topo\_fact} (\sphinxstyleliteralemphasis{float}) \textendash{} Topography factor. It runs in between 0 (at the beginning of the
simulation) and 1 (once the simulation has been run for \sphinxcode{topo\_time} seconds).

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.topography.Topography1d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.topography.Topography1d.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{x}, \emph{topo\_type='flat\_terrain'}, \emph{topo\_time=datetime.timedelta(0)}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{x} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.axis.Axis}]{\sphinxcrossref{\sphinxcode{Axis}}}} object representing the underlying horizontal axis.

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. Either ‘flat\_terrain’ (default), ‘gaussian’
or ‘user\_defined’.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxcode{datetime.timedelta} object representing the elapsed simulation time
after which the topography should stop increasing. Default is 0, corresponding to a
time-invariant terrain surface-height.

\item {} 
\sphinxstyleliteralstrong{**topo\_max\_height} (\sphinxstyleliteralemphasis{float}) \textendash{} When \sphinxcode{topo\_type} is ‘gaussian’, maximum mountain
height (in meters). Default is 500.

\item {} 
\sphinxstyleliteralstrong{**topo\_width\_x} (\sphinxstyleliteralemphasis{float}) \textendash{} When \sphinxcode{topo\_type} is ‘gaussian’, mountain half-width
(in meters). Default is 10000.

\item {} 
\sphinxstyleliteralstrong{**topo\_str} (\sphinxstyleliteralemphasis{str}) \textendash{} When \sphinxcode{topo\_type} is ‘user\_defined’, terrain profile expression
in the independent variable \(x\). Must be fully C++-compliant.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (grids.topography.Topography1d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.topography.Topography1d.update}}\pysiglinewithargsret{\sphinxbfcode{update}}{\emph{time}}{}
Update topography at current simulation time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxcode{datetime.timedelta} object, representing the elapsed simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Topography2d (class in grids.topography)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.topography.Topography2d}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{grids.topography.}\sphinxbfcode{Topography2d}}{\emph{grid}, \emph{topo\_type='flat\_terrain'}, \emph{topo\_time=datetime.timedelta(0)}, \emph{**kwargs}}{}
Two-dimensional topography.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{topo} (\sphinxstyleliteralemphasis{array\_like}) \textendash{} A \sphinxhref{http://xarray.pydata.org/en/stable/generated/xarray.DataArray.html\#xarray.DataArray}{\sphinxcode{xarray.DataArray}} storing the topography (in meters).

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxstyleliteralemphasis{str}) \textendash{} Topography type. Either ‘flat\_terrain’, ‘gaussian’, ‘schaer’ or ‘user\_defined’.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxcode{datetime.timedelta} object representing the elapsed simulation time
after which the topography should stop increasing.

\item {} 
\sphinxstyleliteralstrong{topo\_fact} (\sphinxstyleliteralemphasis{float}) \textendash{} Topography factor. It runs in between 0 (at the beginning of the
simulation) and 1 (once the simulation has been run for \sphinxcode{topo\_time} seconds).

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (grids.topography.Topography2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.topography.Topography2d.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{grid}, \emph{topo\_type='flat\_terrain'}, \emph{topo\_time=datetime.timedelta(0)}, \emph{**kwargs}}{}
Constructor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.xy_grid.XYGrid}]{\sphinxcrossref{\sphinxcode{XYGrid}}}} object representing the underlying grid.

\item {} 
\sphinxstyleliteralstrong{topo\_type} (\sphinxtitleref{str}, optional) \textendash{} Topography type. Either ‘flat\_terrain’ (default), ‘gaussian’,
‘schaer’ or ‘user\_defined’.

\item {} 
\sphinxstyleliteralstrong{topo\_time} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxcode{datetime.timedelta} object representing the elapsed simulation time
after which the topography should stop increasing. Default is 0, corresponding to a
time-invariant terrain surface-height.

\item {} 
\sphinxstyleliteralstrong{**topo\_max\_height} (\sphinxstyleliteralemphasis{float}) \textendash{} When \sphinxcode{topo\_type} is ‘gaussian’, maximum mountain
height (in meters). Default is 500.

\item {} 
\sphinxstyleliteralstrong{**topo\_width\_x} (\sphinxstyleliteralemphasis{float}) \textendash{} When \sphinxcode{topo\_type} is ‘gaussian’, mountain half-width in
\(x\)-direction (in meters). Default is 10000.

\item {} 
\sphinxstyleliteralstrong{**topo\_width\_y} (\sphinxstyleliteralemphasis{float}) \textendash{} When \sphinxcode{topo\_type} is ‘gaussian’, mountain half-width in
\(y\)-direction (in meters). Default is 10000.

\item {} 
\sphinxstyleliteralstrong{**topo\_str} (\sphinxstyleliteralemphasis{str}) \textendash{} When \sphinxcode{topo\_type} is ‘user\_defined’, terrain profile expression
in the independent variables \(x\) and \(y\). Must be fully C++-compliant.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (grids.topography.Topography2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.topography.Topography2d.plot}}\pysiglinewithargsret{\sphinxbfcode{plot}}{\emph{grid}, \emph{**kwargs}}{}
Plot the topography using the \sphinxhref{https://matplotlib.org/tutorials/toolkits/mplot3d.html}{mplot3d toolkit}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{grid} (\sphinxstyleliteralemphasis{obj}) \textendash{} {\hyperref[\detokenize{api:grids.xy_grid.XYGrid}]{\sphinxcrossref{\sphinxcode{XYGrid}}}} object representing the underlying grid.

\item {} 
\sphinxstyleliteralstrong{**kwargs} \textendash{} Keyword arguments to be forwarded to \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.pyplot.figure.html\#matplotlib.pyplot.figure}{\sphinxcode{matplotlib.pyplot.figure()}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (grids.topography.Topography2d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.topography.Topography2d.update}}\pysiglinewithargsret{\sphinxbfcode{update}}{\emph{time}}{}
Update topography at current simulation time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{obj}) \textendash{} \sphinxcode{datetime.timedelta} object, representing the elapsed simulation time.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Parsers}
\label{\detokenize{api:parsers}}\index{Parser1d (class in grids.parser.parser\_1d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.parser.parser_1d.Parser1d}}\pysigline{\sphinxbfcode{class }\sphinxcode{grids.parser.parser\_1d.}\sphinxbfcode{Parser1d}}
Cython wrapper for the C++ class \sphinxcode{parser\_1d\_cpp}.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\sphinxstyleliteralstrong{parser} (\sphinxstyleliteralemphasis{obj}) \textendash{} Pointer to a \sphinxcode{parser\_1d\_cpp} object.

\end{description}\end{quote}
\index{evaluate() (grids.parser.parser\_1d.Parser1d method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:grids.parser.parser_1d.Parser1d.evaluate}}\pysiglinewithargsret{\sphinxbfcode{evaluate}}{}{}
Evaluate the expression.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxhref{https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\sphinxcode{numpy.ndarray}} of the evaluations.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Utilities}
\label{\detokenize{api:module-utils}}\label{\detokenize{api:utilities}}\index{utils (module)}
Some useful utilities.
\index{convert\_datetime64\_to\_datetime() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.convert_datetime64_to_datetime}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{convert\_datetime64\_to\_datetime}}{\emph{time}}{}
Convert a \sphinxcode{numpy.datetime64} object to a \sphinxcode{datetime.datetime}.
The implementation has been retrieved from
\sphinxurl{https://stackoverflow.com/questions/13703720/converting-between-datetime-timestamp-and-datetime64}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{time} (\sphinxstyleliteralemphasis{obj}) \textendash{} The \sphinxcode{numpy.datetime64} object to convert.

\item[{Returns}] \leavevmode
The converted \sphinxcode{datetime.datetime} object.

\end{description}\end{quote}

\end{fulllineitems}

\index{equal\_to() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.equal_to}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{equal\_to}}{\emph{a}, \emph{b}, \emph{tol=None}}{}
Compare floating point numbers (or arrays of floating point numbers),
properly accounting for round-off errors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{a} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Left-hand side.

\item {} 
\sphinxstyleliteralstrong{b} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Right-hand side.

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxtitleref{float}, optional) \textendash{} Tolerance.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{obj:{}`True{}`} if \sphinxcode{a} is equal to \sphinxcode{b} up to \sphinxcode{tol}, \sphinxcode{obj:{}`False{}`} otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_factor() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.get_factor}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{get\_factor}}{\emph{units}}{}
Convert units prefix to the corresponding factor.
For the conversion, the \sphinxhref{http://cfconventions.org/}{CF Conventions} are used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{units} (\sphinxstyleliteralemphasis{str}) \textendash{} The units.

\item[{Returns}] \leavevmode
The factor.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{greater\_or\_equal\_than() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.greater_or_equal_than}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{greater\_or\_equal\_than}}{\emph{a}, \emph{b}, \emph{tol=None}}{}
Compare floating point numbers (or arrays of floating point numbers),
properly accounting for round-off errors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{a} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Left-hand side.

\item {} 
\sphinxstyleliteralstrong{b} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Right-hand side.

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxtitleref{float}, optional) \textendash{} Tolerance.

\end{itemize}

\item[{Returns}] \leavevmode
obj:\sphinxtitleref{True} if \sphinxcode{a} is greater than or equal to \sphinxcode{b} up to \sphinxcode{tol}, obj:\sphinxtitleref{False} otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{greater\_than() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.greater_than}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{greater\_than}}{\emph{a}, \emph{b}, \emph{tol=None}}{}
Compare floating point numbers (or arrays of floating point numbers),
properly accounting for round-off errors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{a} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Left-hand side.

\item {} 
\sphinxstyleliteralstrong{b} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Right-hand side.

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxtitleref{float}, optional) \textendash{} Tolerance.

\end{itemize}

\item[{Returns}] \leavevmode
obj:\sphinxtitleref{True} if \sphinxcode{a} is greater than \sphinxcode{b} up to \sphinxcode{tol}, obj:\sphinxtitleref{False} otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{reverse\_colormap() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.reverse_colormap}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{reverse\_colormap}}{\emph{cmap}, \emph{name=None}}{}
Reverse a Matplotlib colormap.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{cmap} (\sphinxstyleliteralemphasis{obj}) \textendash{} The \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.colors.LinearSegmentedColormap.html\#matplotlib.colors.LinearSegmentedColormap}{\sphinxcode{matplotlib.colors.LinearSegmentedColormap}} to invert.

\item {} 
\sphinxstyleliteralstrong{name} (\sphinxtitleref{str}, optional) \textendash{} The name of the reversed colormap. By default, this is obtained by
appending ‘\_r’ to the name of the input colormap.

\end{itemize}

\item[{Returns}] \leavevmode
The reversed \sphinxhref{https://matplotlib.org/2.1.1/api/\_as\_gen/matplotlib.colors.LinearSegmentedColormap.html\#matplotlib.colors.LinearSegmentedColormap}{\sphinxcode{matplotlib.colors.LinearSegmentedColormap}}.

\end{description}\end{quote}
\paragraph{References}

\sphinxurl{https://stackoverflow.com/questions/3279560/invert-colormap-in-matplotlib}

\end{fulllineitems}

\index{set\_namelist() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.set_namelist}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{set\_namelist}}{\emph{user\_namelist=None}}{}
Place the user-defined namelist module in the Python search path.
This is achieved by physically copying the content of the user-provided
module into GT4ESS/namelist.py.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{user\_namelist} (\sphinxstyleliteralemphasis{str}) \textendash{} Path to the user-defined namelist. If not specified,
the default namelist GT4ESS/\_namelist.py is used.

\end{description}\end{quote}

\end{fulllineitems}

\index{smaller\_or\_equal\_than() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.smaller_or_equal_than}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{smaller\_or\_equal\_than}}{\emph{a}, \emph{b}, \emph{tol=None}}{}
Compare floating point numbers (or arrays of floating point numbers),
properly accounting for round-off errors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{a} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Left-hand side.

\item {} 
\sphinxstyleliteralstrong{b} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Right-hand side.

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxtitleref{float}, optional) \textendash{} Tolerance.

\end{itemize}

\item[{Returns}] \leavevmode
obj:\sphinxtitleref{True} if \sphinxcode{a} is smaller than or equal to \sphinxcode{b} up to \sphinxcode{tol}, obj:\sphinxtitleref{False} otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{smaller\_than() (in module utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api:utils.smaller_than}}\pysiglinewithargsret{\sphinxcode{utils.}\sphinxbfcode{smaller\_than}}{\emph{a}, \emph{b}, \emph{tol=None}}{}
Compare floating point numbers (or arrays of floating point numbers),
properly accounting for round-off errors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{a} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Left-hand side.

\item {} 
\sphinxstyleliteralstrong{b} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{array\_like}) \textendash{} Right-hand side.

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxtitleref{float}, optional) \textendash{} Tolerance.

\end{itemize}

\item[{Returns}] \leavevmode
obj:\sphinxtitleref{True} if \sphinxcode{a} is smaller than \sphinxcode{b} up to \sphinxcode{tol}, obj:\sphinxtitleref{False} otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{g}
\item {\sphinxstyleindexentry{grids.topography}}\sphinxstyleindexpageref{api:\detokenize{module-grids.topography}}
\indexspace
\bigletter{n}
\item {\sphinxstyleindexentry{namelist}}\sphinxstyleindexpageref{api:\detokenize{module-namelist}}
\indexspace
\bigletter{u}
\item {\sphinxstyleindexentry{utils}}\sphinxstyleindexpageref{api:\detokenize{module-utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}